// ----------------------------------------------------------------------------
//  FILE: HAIOmniSh_Shared.hpp
//  DATE: Sat, Jan 26 22:50:46 2019 -0500
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kHAIOmniSh
{
    
    // ------------------------------------------------------------------------
    //  The maximum number of various types of supporting hardware modules
    //  that we have to deal with.
    //  
    //  These are persisted, so add new ones at the end
    //                  
    // ------------------------------------------------------------------------
    const tCIDLib::TCard4 c4MaxAreas = 8;
    const tCIDLib::TCard4 c4MaxButtons = 128;
    const tCIDLib::TCard4 c4MaxEnclosures = 8;
    const tCIDLib::TCard4 c4MaxExps = 8;
    const tCIDLib::TCard4 c4MaxMsgs = 128;
    const tCIDLib::TCard4 c4MaxThermos = 64;
    const tCIDLib::TCard4 c4MaxUnits = 511;
    const tCIDLib::TCard4 c4MaxZones = 176;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tHAIOmniSh
{
    
    // ------------------------------------------------------------------------
    //  These are the types of modules we support. These are persisted,
    //  so add new ones at the end.
    //                  
    // ------------------------------------------------------------------------
    enum EItemTypes
    {
        EItem_Unknown
        , EItem_Area
        , EItem_Button
        , EItem_Code
        , EItem_Message
        , EItem_Thermo
        , EItem_Unit
        , EItem_Zone
        , EItemTypes_Count
        , EItemTypes_Min = EItem_Unknown
        , EItemTypes_Max = EItem_Zone
    };
     EItemTypes eXlatEItemTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
     const TString& strXlatEItemTypes(const EItemTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
     tCIDLib::TBoolean bIsValidEnum(const EItemTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in units to indicate what type of unit. Unused needs to be the
    //  first value, so that it comes out zero!
    //  
    //  Add new ones at the end! These are presisted.
    //                  
    // ------------------------------------------------------------------------
    enum EUnitTypes
    {
        EUnit_Unused
        , EUnit_Binary
        , EUnit_Dimmer
        , EUnit_Flag
        , EUnitTypes_Count
        , EUnitTypes_Min = EUnit_Unused
        , EUnitTypes_Max = EUnit_Flag
    };
     EUnitTypes eXlatEUnitTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
     const TString& strXlatEUnitTypes(const EUnitTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
     tCIDLib::TBoolean bIsValidEnum(const EUnitTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in zones to indicate what type of zone. Unused needs to be the
    //  first value, so that it comes out zero! There are other zone types
    //  but these are the only ones we support for now.
    //  
    //  Add new ones at the end! These are presisted.
    //                  
    // ------------------------------------------------------------------------
    enum EZoneTypes
    {
        EZone_Unused
        , EZone_Alarm
        , EZone_Humidity
        , EZone_Temp
        , EZoneTypes_Count
        , EZoneTypes_Min = EZone_Unused
        , EZoneTypes_Max = EZone_Temp
    };
     EZoneTypes eXlatEZoneTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
     const TString& strXlatEZoneTypes(const EZoneTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
     tCIDLib::TBoolean bIsValidEnum(const EZoneTypes eVal);

}

#pragma CIDLIB_POPPACK

 TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniSh::EItemTypes eToStream);
 TBinInStream& operator>>(TBinInStream& strmSrc, tHAIOmniSh::EItemTypes& eToFill);
 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniSh::EItemTypes* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniSh::EItemTypes* const aeList, const tCIDLib::TCard4 c4Count);

 TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniSh::EUnitTypes eToStream);
 TBinInStream& operator>>(TBinInStream& strmSrc, tHAIOmniSh::EUnitTypes& eToFill);
 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniSh::EUnitTypes* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniSh::EUnitTypes* const aeList, const tCIDLib::TCard4 c4Count);

 TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniSh::EZoneTypes eToStream);
 TBinInStream& operator>>(TBinInStream& strmSrc, tHAIOmniSh::EZoneTypes& eToFill);
 tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniSh::EZoneTypes* const aeList, const tCIDLib::TCard4 c4Count);
 tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniSh::EZoneTypes* const aeList, const tCIDLib::TCard4 c4Count);

