// ----------------------------------------------------------------------------
//  FILE: HAIOmniTCP2Sh_Shared.hpp
//  DATE: Fri, Feb 12 21:14:16 2021 -0500
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kHAIOmniTCP2Sh
{
    
    // ------------------------------------------------------------------------
    //  The maximum number of various types of supporting hardware modules
    //  that we have to deal with.
    //  
    //  These are persisted, so add new ones at the end
    //                  
    // ------------------------------------------------------------------------
    constexpr tCIDLib::TCard4 c4MaxAreas = 8;
    constexpr tCIDLib::TCard4 c4MaxButtons = 128;
    constexpr tCIDLib::TCard4 c4MaxEnclosures = 8;
    constexpr tCIDLib::TCard4 c4MaxExps = 8;
    constexpr tCIDLib::TCard4 c4MaxMsgs = 128;
    constexpr tCIDLib::TCard4 c4MaxThermos = 64;
    constexpr tCIDLib::TCard4 c4MaxUnits = 511;
    constexpr tCIDLib::TCard4 c4MaxZones = 176;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tHAIOmniTCP2Sh
{
    
    // ------------------------------------------------------------------------
    //  These are the types of alarm types this Omni supported.
    //                  
    // ------------------------------------------------------------------------
    enum class EAlarmTypes
    {
        Burglary
        , Fire
        , Gas
        , Auxillary
        , Freeze
        , Water
        , Duress
        , Temperature
        , Unknown
        , Count
        , Min = Burglary
        , Max = Unknown
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EAlarmTypes eXlatEAlarmTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEAlarmTypes(const EAlarmTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EAlarmTypes eVal);

    inline tHAIOmniTCP2Sh::EAlarmTypes operator++(tHAIOmniTCP2Sh::EAlarmTypes& eVal, int)
    {
        tHAIOmniTCP2Sh::EAlarmTypes eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EAlarmTypes(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EAlarmTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EAlarmTypes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EAlarmTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  These are the area arming modes supported
    //                  
    // ------------------------------------------------------------------------
    enum class EArmModes
    {
        Off
        , Day
        , Night
        , Away
        , Vacation
        , DayInstant
        , NightDelay
        , Count
        , Min = Off
        , Max = NightDelay
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EArmModes eXlatEArmModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEArmModes(const EArmModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    HAIOMNITCP2SHEXP tCIDLib::TVoid FormatEArmModes
    (
                   TString&            strTarget
        , const    TString&            strPrefix
        , const    tCIDLib::TCh        chSepChar
        , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
    );
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EArmModes eVal);

    inline tHAIOmniTCP2Sh::EArmModes operator++(tHAIOmniTCP2Sh::EArmModes& eVal, int)
    {
        tHAIOmniTCP2Sh::EArmModes eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EArmModes(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EArmModes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EArmModes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EArmModes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  These are the fan modes supported
    //                  
    // ------------------------------------------------------------------------
    enum class EFanModes
    {
        Auto
        , On
        , Cycle
        , Count
        , Min = Auto
        , Max = Cycle
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EFanModes eXlatEFanModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEFanModes(const EFanModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    HAIOMNITCP2SHEXP tCIDLib::TVoid FormatEFanModes
    (
                   TString&            strTarget
        , const    TString&            strPrefix
        , const    tCIDLib::TCh        chSepChar
        , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
    );
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EFanModes eVal);

    inline tHAIOmniTCP2Sh::EFanModes operator++(tHAIOmniTCP2Sh::EFanModes& eVal, int)
    {
        tHAIOmniTCP2Sh::EFanModes eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EFanModes(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EFanModes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EFanModes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EFanModes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  These are the types of modules we support. These are persisted,
    //  so add new ones at the end.
    //                  
    // ------------------------------------------------------------------------
    enum class EItemTypes
    {
        Unknown
        , Area
        , Button
        , Code
        , Msg
        , Thermo
        , Unit
        , Zone
        , Count
        , Min = Unknown
        , Max = Zone
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EItemTypes eXlatEItemTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEItemTypes(const EItemTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EItemTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EItemTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EItemTypes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EItemTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  These are the thermostat modes supported.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoModes
    {
        Off
        , Heat
        , Cool
        , Auto
        , EmHeat
        , Count
        , Min = Off
        , Max = EmHeat
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EThermoModes eXlatEThermoModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEThermoModes(const EThermoModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    HAIOMNITCP2SHEXP tCIDLib::TVoid FormatEThermoModes
    (
                   TString&            strTarget
        , const    TString&            strPrefix
        , const    tCIDLib::TCh        chSepChar
        , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
    );
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EThermoModes eVal);

    inline tHAIOmniTCP2Sh::EThermoModes operator++(tHAIOmniTCP2Sh::EThermoModes& eVal, int)
    {
        tHAIOmniTCP2Sh::EThermoModes eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EThermoModes(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EThermoModes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EThermoModes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EThermoModes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  These are the types of thermos, which we get from the Omni or
    //  user. It tells us what capabilities it has.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoTypes
    {
        Unused
        , AutoHC
        , HeatCool
        , Heat
        , Cool
        , SP
        , Count
        , Min = Unused
        , Max = SP
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EThermoTypes eXlatEThermoTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEThermoTypes(const EThermoTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EThermoTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EThermoTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EThermoTypes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EThermoTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  Used in units to indicate what type of unit. Unused needs to be the
    //  first value, so that it comes out zero!
    //  
    //  Add new ones at the end! These are presisted.
    //                  
    // ------------------------------------------------------------------------
    enum class EUnitTypes
    {
        Unused
        , Dimmer
        , Flag
        , Switch
        , Count
        , Min = Unused
        , Max = Switch
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EUnitTypes eXlatEUnitTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEUnitTypes(const EUnitTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EUnitTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EUnitTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EUnitTypes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EUnitTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  The zone arming modes
    //                  
    // ------------------------------------------------------------------------
    enum class EZoneArmModes
    {
        Disarmed
        , Armed
        , BypassUser
        , BypassSystem
        , Count
        , Min = Disarmed
        , Max = BypassSystem
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EZoneArmModes eXlatEZoneArmModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEZoneArmModes(const EZoneArmModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    HAIOMNITCP2SHEXP tCIDLib::TVoid FormatEZoneArmModes
    (
                   TString&            strTarget
        , const    TString&            strPrefix
        , const    tCIDLib::TCh        chSepChar
        , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
    );
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EZoneArmModes eVal);

    inline tHAIOmniTCP2Sh::EZoneArmModes operator++(tHAIOmniTCP2Sh::EZoneArmModes& eVal, int)
    {
        tHAIOmniTCP2Sh::EZoneArmModes eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EZoneArmModes(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneArmModes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EZoneArmModes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EZoneArmModes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  The zone latching modes
    //                  
    // ------------------------------------------------------------------------
    enum class EZoneLatch
    {
        Secure
        , Tripped
        , Reset
        , Count
        , Min = Secure
        , Max = Reset
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EZoneLatch eXlatEZoneLatch(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEZoneLatch(const EZoneLatch eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    HAIOMNITCP2SHEXP tCIDLib::TVoid FormatEZoneLatch
    (
                   TString&            strTarget
        , const    TString&            strPrefix
        , const    tCIDLib::TCh        chSepChar
        , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
    );
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EZoneLatch eVal);

    inline tHAIOmniTCP2Sh::EZoneLatch operator++(tHAIOmniTCP2Sh::EZoneLatch& eVal, int)
    {
        tHAIOmniTCP2Sh::EZoneLatch eTmp = eVal;
        eVal = tHAIOmniTCP2Sh::EZoneLatch(int(eVal)+1);
        return eTmp;
    }

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneLatch eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EZoneLatch& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EZoneLatch(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  Used in zones to indicate what type of zone. Unused needs to be the
    //  first value, so that it comes out zero! There are other zone types
    //  but these are the only ones we support for now.
    //  
    //  Add new ones at the end! These are presisted.
    //                  
    // ------------------------------------------------------------------------
    enum class EZoneTypes
    {
        Unused
        , Alarm
        , Fire
        , Humidity
        , Intrusion
        , Motion
        , Temp
        , Water
        , Count
        , Min = Unused
        , Max = Water
    };
    [[nodiscard]] HAIOMNITCP2SHEXP EZoneTypes eXlatEZoneTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] HAIOMNITCP2SHEXP const TString& strXlatEZoneTypes(const EZoneTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] HAIOMNITCP2SHEXP tCIDLib::TBoolean bIsValidEnum(const EZoneTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tHAIOmniTCP2Sh::EZoneTypes& eToFill)
    {
        eToFill = tHAIOmniTCP2Sh::EZoneTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
}

#pragma CIDLIB_POPPACK

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EAlarmTypes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EAlarmTypes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EArmModes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EArmModes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EFanModes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EFanModes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EItemTypes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EItemTypes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EThermoModes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EThermoModes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EThermoTypes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EThermoTypes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EUnitTypes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EUnitTypes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EZoneArmModes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneArmModes* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EZoneLatch* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneLatch* const aeList, const tCIDLib::TCard4 c4Count);

HAIOMNITCP2SHEXP tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tHAIOmniTCP2Sh::EZoneTypes* const aeList, const tCIDLib::TCard4 c4Count);
HAIOMNITCP2SHEXP tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tHAIOmniTCP2Sh::EZoneTypes* const aeList, const tCIDLib::TCard4 c4Count);

