// ----------------------------------------------------------------------------
//  FILE: ZWaveUSB3Sh_Shared.hpp
//  DATE: Fri, Feb 14 18:49:47 2020 -0500
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kZWaveUSB3Sh
{
    
    // ------------------------------------------------------------------------
    //  The names of the commands that the InvokeCmd field accepts
    //                  
    // ------------------------------------------------------------------------
    ZWUSB3SHEXPORT const extern TString strInvokeCmd_EnableTrace;
    ZWUSB3SHEXPORT const extern TString strInvokeCmd_FlushTrace;
    ZWUSB3SHEXPORT const extern TString strInvokeCmd_RecycleTrace;
    ZWUSB3SHEXPORT const extern TString strInvokeCmd_SetCfgParam;
    
    // ------------------------------------------------------------------------
    //  The names of the commands that we support via the bSendCmd()
    //  backdoor driver command.
    //                  
    // ------------------------------------------------------------------------
    ZWUSB3SHEXPORT const extern TString strSendData_ApproveNewUnits;
    ZWUSB3SHEXPORT const extern TString strSendData_AssocToDrv;
    ZWUSB3SHEXPORT const extern TString strSendData_DisableUnit;
    ZWUSB3SHEXPORT const extern TString strSendData_DoAutoCfg;
    ZWUSB3SHEXPORT const extern TString strSendData_ForceRescan;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryAssoc;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryConfig;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryCfgParam;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryGrpCnt;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryUnitReport;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryRepStatus;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryStatusInfo;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryTraceLevel;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryUnitInfo;
    ZWUSB3SHEXPORT const extern TString strSendData_QueryWakeup;
    ZWUSB3SHEXPORT const extern TString strSendData_RemoveAssoc;
    ZWUSB3SHEXPORT const extern TString strSendData_Replicate;
    ZWUSB3SHEXPORT const extern TString strSendData_ResetUnitCfg;
    ZWUSB3SHEXPORT const extern TString strSendData_SetAssoc;
    ZWUSB3SHEXPORT const extern TString strSendData_SetConfig;
    ZWUSB3SHEXPORT const extern TString strSendData_SetCfgParam;
    ZWUSB3SHEXPORT const extern TString strSendData_SetTrace;
    ZWUSB3SHEXPORT const extern TString strSendData_Type;
    ZWUSB3SHEXPORT const extern TString strSendData_PollPref;
    
    // ------------------------------------------------------------------------
    //  These are some more often used unit option keys for options that
    //  are defined by CC Impls themselves, i.e. not just set by the
    //  unit handler object that creates them. Most are of the latter type
    //  but we could have some that a particular CC Impl requires to be
    //  there and it's completely specific so that CC.
    //  
    //  Note that these have a replacement parameter in them, which gets
    //  replaced with the end point id. If the CC Impl is not an end point
    //  then that will be zero.
    //                  
    // ------------------------------------------------------------------------
    ZWUSB3SHEXPORT const extern TString strCCOpt_Whatever;
    ZWUSB3SHEXPORT const extern TString strCCOpt_Prefix;
    
    // ------------------------------------------------------------------------
    //  Some common unit level attributes. When the client side driver asks
    //  for the available editable attributes of the unit, these are
    //  provided by the unit info object and are direct edits of members
    //  of that class.
    //  
    //  These are separate from 'unit options' which are driven by the
    //  the unit handler and his CC impl objects. These start with
    //  /Unit/ and those start with /UnitOpt/ to distinguish them since
    //  these are members and those are stored in the option values
    //  collection.
    //  
    //  CC Impl level attributes start with /CCOpt/x/ to distinguish
    //  them from the other two, where x is the instance id. If zero then
    //  the CC Impl isn't an end point.
    //  
    //                  
    // ------------------------------------------------------------------------
    ZWUSB3SHEXPORT const extern TString strUAttr_Prefix;
    ZWUSB3SHEXPORT const extern TString strUAttr_Name;
    
    // ------------------------------------------------------------------------
    //  These are keys for some of the unit level editable options. Though
    //  these may in some cases drive the actions of CC Impls, they are
    //  defined at the unit level. So they never have to deal with per-
    //  instance issues. That also means that
    //                  
    // ------------------------------------------------------------------------
    ZWUSB3SHEXPORT const extern TString strUOpt_Prefix;
    ZWUSB3SHEXPORT const extern TString strUOpt_AsLight;
    ZWUSB3SHEXPORT const extern TString strUOpt_CurTempMax;
    ZWUSB3SHEXPORT const extern TString strUOpt_CurTempMin;
    ZWUSB3SHEXPORT const extern TString strUOpt_SendTrigger;
    ZWUSB3SHEXPORT const extern TString strUOpt_TempScale;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tZWaveUSB3Sh
{
    
    // ------------------------------------------------------------------------
    //  The sensor types supported by the (now obsolete) Aeon multi-sensor
    //  unit handler. This is like EGenMSTypes but only includes those that
    //  the old Aeon multi-sensor handler understands. At some point if we
    //  can translate the few devices that use that old handler to the new
    //  one, we could get rid of this.
    //                  
    // ------------------------------------------------------------------------
    enum class EAeonMSTypes
    {
        Humidity
        , Lux
        , Motion
        , Temp
        , UV
        , Count
        , Min = Humidity
        , Max = UV
    };
    ZWUSB3SHEXPORT EAeonMSTypes eXlatEAeonMSTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEAeonMSTypes(const EAeonMSTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EAeonMSTypes eVal);

    
    // ------------------------------------------------------------------------
    //  This is used by some of the binary sensor oriented unit handlers, to
    //  indicate what type of unit. We support a basic set of them. We
    //  have an Other type if it's not one of these. These are ones
    //  defined in the Z-Wave notification class, but we don't have to
    //  only use them with that class.
    //  
    //  There are others not of the binary sort. They would be used with
    //  another handler.
    //                  
    // ------------------------------------------------------------------------
    enum class EBinSensorTypes
    {
        CO
        , CO2
        , Door
        , Glass
        , Heat
        , Intrusion
        , Leak
        , Motion
        , Smoke
        , Tilt
        , Count
        , Min = CO
        , Max = Tilt
    };
    ZWUSB3SHEXPORT EBinSensorTypes eXlatEBinSensorTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEBinSensorTypes(const EBinSensorTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TVoid FormatEBinSensorTypes
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
        );
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EBinSensorTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used to access some binary results, so that we can get an off
    //  or on or error state all in one value. Error is first so that
    //  if the value is non-zero then it is not in error.
    //                  
    // ------------------------------------------------------------------------
    enum class EBinStates
    {
        Error
        , Off
        , On
        , Count
        , Min = Error
        , Max = On
    };
    ZWUSB3SHEXPORT EBinStates eXlatEBinStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEBinStates(const EBinStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EBinStates eVal);

    
    // ------------------------------------------------------------------------
    //  The command classes that we support.
    //  
    //  !!!IF YOU CHANGE these, it's going to affect the device info
    //  files potentially and the device info DTD so update those!
    //  
    //  You also need to update the TZWClassInfo class which is used to
    //  track class info and will set default info for each supported
    //  class.
    //                  
    // ------------------------------------------------------------------------
    enum class ECClasses
    {
        None
        , Association
        , AssocGrpInfo
        , Basic
        , Battery
        , BinSensor
        , BinSwitch
        , CentralScene
        , ClrSwitch
        , Config
        , DoorLock
        , EntryCtrl
        , Indicator
        , Lock
        , ManSpec
        , Meter
        , MultiCh
        , MultiChAssoc
        , MLSensor
        , MLSwitch
        , Naming
        , Notification
        , PowerLev
        , SceneAct
        , SceneActConf
        , Security
        , SwitchAll
        , ThermoFanMode
        , ThermoFanState
        , ThermoMode
        , ThermoState
        , ThermoSetPnt
        , Version
        , Wakeup
        , ZWPlusInfo
        , Count
        , Min = None
        , Max = ZWPlusInfo
    };
    ZWUSB3SHEXPORT ECClasses eXlatECClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatECClasses(const ECClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumECClasses(const ECClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT ECClasses eAltNumECClasses(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ECClasses eVal);

    
    // ------------------------------------------------------------------------
    //  The basic device types. There are just a small number.
    //                  
    // ------------------------------------------------------------------------
    enum class EDevTypes
    {
        None
        , Controller
        , RoutingSlave
        , Slave
        , StaticCtrl
        , Count
        , Min = None
        , Max = StaticCtrl
    };
    ZWUSB3SHEXPORT EDevTypes eXlatEDevTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEDevTypes(const EDevTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEDevTypes(const EDevTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EDevTypes eAltNumEDevTypes(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EDevTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The driver keeps a member of this type that it keeps set to remember
    //  its state, and it also has a text field that it loads the text of the
    //  current value into, to let the outside world know his state.
    //                  
    // ------------------------------------------------------------------------
    enum class EDrvStates
    {
        Startup
        , Replicating
        , SecureJoin
        , RepFailed
        , RepSucceeded
        , PrepUnits
        , Ready
        , Count
        , Min = Startup
        , Max = Ready
        , FirstRepState = Replicating
        , LastRepState = RepSucceeded
    };
    ZWUSB3SHEXPORT const TString& strLoadEDrvStates(const EDrvStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TVoid FormatEDrvStates
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EDrvStates eVal);

    
    // ------------------------------------------------------------------------
    //  The sensor types supported by our NMCMSensor unit handler, to indicate
    //  the types of sensors supported.
    //                  
    // ------------------------------------------------------------------------
    enum class EGenMSTypes
    {
        Humidity
        , Lux
        , Motion
        , Temp
        , UV
        , DoorWnd
        , DigInput
        , Voltage
        , Switch
        , Count
        , Min = Humidity
        , Max = Switch
    };
    ZWUSB3SHEXPORT EGenMSTypes eXlatEGenMSTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEGenMSTypes(const EGenMSTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EGenMSTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The generic types that we understand. BE SURE TO update the
    //  DTD in the DevInfo directory since it lists these as the
    //  available generic types.
    //                  
    // ------------------------------------------------------------------------
    enum class EGenTypes
    {
        None
        , GenCtrl
        , BinSensor
        , BinSwitch
        , EntryCtrl
        , MLSensor
        , MLSwitch
        , NotSensor
        , StaticCtrl
        , Thermo
        , Count
        , Min = None
        , Max = Thermo
    };
    ZWUSB3SHEXPORT EGenTypes eXlatEGenTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEGenTypes(const EGenTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEGenTypes(const EGenTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EGenTypes eAltNumEGenTypes(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EGenTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used by the Notification class, to indicate what type of
    //  basic notification it expects, the new type or the old alarm
    //  type.
    //  
    //      NotEvent   : The new style notification event at offset 7
    //      AlarmLevel : The old alarm level
    //                  
    // ------------------------------------------------------------------------
    enum class ENotEvTypes
    {
        NotEvent
        , AlarmLevel
        , Count
        , Min = NotEvent
        , Max = AlarmLevel
    };
    ZWUSB3SHEXPORT ENotEvTypes eXlatENotEvTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatENotEvTypes(const ENotEvTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ENotEvTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used by the Notification class, to indicate how to interpret a
    //  configured notification id. There are multiple ways that we may
    //  need to match incoming notification/alarm reports, and this tells
    //  us how.
    //  
    //  The NotId values indicated in device info files can be one or two
    //  bytes, and can represent a number of different combinations of
    //  notification report fields, since there's no telling what kind of
    //  stupidity we'll run into. These are:
    //  
    //      NotType     : The new Notification Type at offset 6, in the low byte
    //      AlarmType   : The old Alarm Type, at offset 2, in the low byte
    //      BothNew     : The new style type (high byte) and new style event
    //                    (low byte) so bytes 6 and 7 together.
    //                  
    // ------------------------------------------------------------------------
    enum class ENotIdTypes
    {
        NotType
        , AlarmType
        , BothNew
        , Count
        , Min = NotType
        , Max = BothNew
    };
    ZWUSB3SHEXPORT ENotIdTypes eXlatENotIdTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatENotIdTypes(const ENotIdTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ENotIdTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used by the TZWOutMsg class, to indicate the priority of the msg. The
    //  Z-Stick object pulls msgs out highest priority first. It's very
    //  important that msgs be sent with the correct priority. See the Z-Stick
    //  class header comments for details.
    //  
    //  These are mapped to the underlying CIDLib queue priorities, since we
    //  use queues to store the msgs on the way in and out.
    //  
    //  See the Z-Stick class for details.
    //                  
    // ------------------------------------------------------------------------
    enum class EMsgPrios
    {
        Async
        , Query
        , Command
        , Reply
        , Wakeup
        , SpecialCmd
        , Security
        , Nonce
        , Local
        , Count
        , Min = Async
        , Max = Local
    };
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EMsgPrios eVal);

    
    // ------------------------------------------------------------------------
    //  Used by the TZWInMsg class, to indicate the overall type of message,
    //  or a timeout if not throwing on timeout.
    //                  
    // ------------------------------------------------------------------------
    enum class EMsgTypes
    {
        Unknown
        , Ack
        , Can
        , Nak
        , Request
        , Response
        , Timeout
        , TransAck
        , Count
        , Min = Unknown
        , Max = TransAck
    };
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EMsgTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used by the multi-level sensor class, maybe some others that use
    //  a similar scheme. It indicates whether, if it's a temp value, the
    //  value should be stored in the received scale, or forced to a
    //  particular scale.
    //                  
    // ------------------------------------------------------------------------
    enum class ETScales
    {
        Actual
        , C
        , F
        , Count
        , Min = Actual
        , Max = F
    };
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ETScales eVal);

    
    // ------------------------------------------------------------------------
    //  These are all of the possible settable thermostat modes. Not all of
    //  these will be available on a given thermostat. The device info file
    //  will list the ones available for that model.
    //  
    //  It kind of sucks that we need to have two separate sources for these
    //  (here and the device info file) but nothing to be done about it.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoModes
    {
        Off
        , Heat
        , Cool
        , Auto
        , Aux
        , Resume
        , Fan
        , Furnace
        , Dry
        , Moist
        , AutoChange
        , EnergyHeat
        , EnergyCool
        , Away
        , Full
        , Count
        , Min = Off
        , Max = Full
    };
    ZWUSB3SHEXPORT EThermoModes eXlatEThermoModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEThermoModes(const EThermoModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEThermoModes(const EThermoModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EThermoModes eAltNumEThermoModes(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EThermoModes eVal);

    
    // ------------------------------------------------------------------------
    //  These are all of the possible settable thermostat fan modes. Not all
    //  of these will be available on a given thermostat. The device info file
    //  will list the ones available for that model.
    //  
    //  It kind of sucks that we need to have two separate sources for these
    //  (here and the device info file) but nothing to be done about it.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoFModes
    {
        AutoLow
        , Low
        , AutoHigh
        , High
        , AutoMedium
        , Medium
        , Circulate
        , HumCirculate
        , LeftRight
        , UpDown
        , Quiet
        , Count
        , Min = AutoLow
        , Max = Quiet
    };
    ZWUSB3SHEXPORT EThermoFModes eXlatEThermoFModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEThermoFModes(const EThermoFModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEThermoFModes(const EThermoFModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EThermoFModes eAltNumEThermoFModes(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EThermoFModes eVal);

    
    // ------------------------------------------------------------------------
    //  These are all of the possible thermostat fan operating states. Not all
    //  of these will be available on a given thermostat. The device info file
    //  will list the ones available for that model.
    //  
    //  It kind of sucks that we need to have two separate sources for these
    //  (here and the device info file) but nothing to be done about it.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoFStates
    {
        Idle
        , On
        , OnHigh
        , OnMedium
        , Circulate
        , HumCirculate
        , RLCirculate
        , UDCirculate
        , Quiet
        , Count
        , Min = Idle
        , Max = Quiet
    };
    ZWUSB3SHEXPORT EThermoFStates eXlatEThermoFStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEThermoFStates(const EThermoFStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEThermoFStates(const EThermoFStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EThermoFStates eAltNumEThermoFStates(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EThermoFStates eVal);

    
    // ------------------------------------------------------------------------
    //  These are all of the possible thermostat operating states. Not all
    //  of these will be available on a given thermostat. The device info file
    //  will list the ones available for that model.
    //  
    //  It kind of sucks that we need to have two separate sources for these
    //  (here and the device info file) but nothing to be done about it.
    //                  
    // ------------------------------------------------------------------------
    enum class EThermoStates
    {
        Idle
        , Heating
        , Cooling
        , Fan
        , PendingHeat
        , PendingCool
        , Vent
        , AuxHeat
        , Heat2
        , Cool2
        , AuxHeat2
        , AuxHeat3
        , Count
        , Min = Idle
        , Max = AuxHeat3
    };
    ZWUSB3SHEXPORT EThermoStates eXlatEThermoStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEThermoStates(const EThermoStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEThermoStates(const EThermoStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EThermoStates eAltNumEThermoStates(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EThermoStates eVal);

    
    // ------------------------------------------------------------------------
    //  Used to set CC impl access flags. Note that the owning unit's
    //  'always on' status also plays into this. If Read is set by itself
    //  and the unit is always on, that means we can read it any time. If
    //  not always on, then either we only get notifications and never read
    //  a value, or ReadOnWake is enabled.
    //                  
    // ------------------------------------------------------------------------
    enum class EUnitAcc : tCIDLib::TCard4
    {
        Read = 0x0001
        , Write = 0x0002
        , ReadOnWake = 0x0004
        , ReadAfterWrite = 0x0008
        , Count = 4
        , None = 0
        , AllBits = 0xF
        , ReadWrite = 0x0003
        , BatteryRead = 0x0005
        , OptReadFlags = 0x000C
        , RWWithFollowup = 0x000B
    };
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EUnitAcc eVal);

    
    // ------------------------------------------------------------------------
    //  The names of the unit handler classes that we support. We have to
    //  gen these up dynamically and don't want to use the RTTI stuff since
    //  that would require that we support a default and copy ctors for
    //  unit classes which they don't otherwise need and it would be a lot
    //  of extra work.
    //  
    //  So the facility class provides a method to gen one up, given the
    //  class name. The discovery/unit info objects have the class name
    //  that is to handle them.
    //                  
    // ------------------------------------------------------------------------
    enum class EUnitClasses
    {
        TAeonBadMFUnit
        , TBinNotSensorUnit
        , TDimmerUnit
        , TDualBinSensorUnit
        , TGenBinSensorUnit
        , TGenDimmerUnit
        , TGenLightSwitchUnit
        , TGenSceneActUnit
        , TGenRGBWUnit
        , TLightSwitchUnit
        , TLockUnit
        , TLockNotUnit
        , TMultiChComboUnit
        , TNChOutletUnit
        , TNonMCMultiSensorUnit
        , TOutletUnit
        , TTempSPUnit
        , TThermoUnit
        , TZWController
        , Count
        , Min = TAeonBadMFUnit
        , Max = TZWController
    };
    ZWUSB3SHEXPORT EUnitClasses eXlatEUnitClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEUnitClasses(const EUnitClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EUnitClasses eVal);

    
    // ------------------------------------------------------------------------
    //  A unit can get a name three ways. Either a default one initially
    //  assigned (which is just Unit_xx, where xx is the hex unit id. Or,
    //  one we got from the unit itself. Or one the user set. We will only
    //  take a new one if a higher type.
    //                  
    // ------------------------------------------------------------------------
    enum class EUnitNameSrcs
    {
        Default
        , Unit
        , User
        , Count
        , Min = Default
        , Max = User
    };
    ZWUSB3SHEXPORT EUnitNameSrcs eXlatEUnitNameSrcs(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEUnitNameSrcs(const EUnitNameSrcs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EUnitNameSrcs eVal);

    
    // ------------------------------------------------------------------------
    //  The current state of a unit, which indicates what needs to be done next.
    //  The primary reason for the driver to exist is to try to keep pushing
    //  each available unit towards Ready state.
    //  
    //  THESE ARE NOT in order, they are grouped by basic unit status. We
    //  can jump backwards in the list.
    //  
    //  --------------------------------
    //  These states are ones that indicate the device is not currently usable.
    //  
    //  Failed        - Something has gone wrong and it's not going to work
    //                  until the user intervenes and fixes it so we want
    //                  to ignore it.
    //  
    //  Disabled      - The user has indicated he want to ignore this one, so
    //                  it will just stay at this state until he changed that
    //                  decision.
    //  
    //  ---------------------------------
    //  These indicate a new unit that we need to get information about,
    //  with the goal of auto-identifying it if we can.
    //  
    //  InitUnit      - Upon finding any new units, we ask for node protocol
    //                  info. This is done synchronously before we go back
    //                  to the driver's polling loop, because there's no way
    //                  to match the response to a unit. So we have to do
    //                  them one at a time.
    //  
    //                  Once this is done, we know if the unit is a listener
    //                  or frequent listener, and if it's a controller (in
    //                  which case we mark it disabled.) This is core info
    //                  need to know in order to do the subsequent steps.
    //  
    //                  Since it is done synchronously, none of our logic or
    //                  the client interface will ever see this state. If
    //                  we can't do this, we mark the unit failed since there
    //                  is something very wrong. This info is coming from
    //                  our own local controller hardware.
    //  
    //  GetUnitInfo   - Once we have initialized a unit successfully, we will
    //                  ask for its node info frame. This will get us the
    //                  non-secure classes. We keep trying it until we get
    //                  a reply.
    //  
    //                  If this fails, and this is a non-listener, we go to
    //                  WaitWakeup state, to let the user know that we need
    //                  to see the unit wakeup so we can talk to it. If we
    //                  get the response, we assume we can move on since it
    //                  is awake right now.
    //  
    //                  If manspec is a non-secure class, we move to
    //                  GetManSpec. Else, if it supports security, we move
    //                  to GetSecureCls. If no security, then no man spec is
    //                  available, so we move to WaitDevInfo.
    //  
    //                  Any unit in this state when the driver starts up or
    //                  after a replication will be pushed back to PingNode
    //                  state just to be safe. Once we get past here we know
    //                  enough to pick back up and keep going.
    //  
    //  WaitWakeup    - We tried a GetUnitInfo and it failed, and we know
    //                  it's a non-listener, so to avoid lots of wasted
    //                  effort we go to this state where we stay until the
    //                  unit wakes up or the user forces it to or forces
    //                  it to send a node info frame. If we get a wakeup
    //                  we'll go back to GetUnitInfo and let it do that
    //                  again. This time it should work.
    //  
    //  GetSecureCls  - We issue a request for secure classes supported.
    //                  If it indicates man spec is supported we move to
    //                  GetManSpec, now knowing it needs to be requested
    //                  securely. If no manspec, then we move to WaitDevInfo.
    //  
    //                  We keep trying till we get it. We know if it's a
    //                  frequent listener and can issue a ping to wake it
    //                  up if we time out(since it may have gone back to
    //                  sleep.)
    //  
    //  GetManSpec    - We issue a request for the manufacturer ids. We keep
    //                  requesting until we get it. At this point we know if
    //                  we need to issue it securely and if it's a frequent
    //                  listener.
    //  
    //                  If we get a reply, we look up the device info file.
    //                  If we don't have one, we move to NoAutoMatch and wait
    //                  for user intervention. If we have the naming class,
    //                  we move to GetName, else we move to WaitApprove.
    //  
    //  GetName       - We issue a request for the unit's name. We will only
    //                  make one attempt. If it times out, we just move on.
    //                  Either way we go to WaitApprove.
    //  
    //  ---------------------------------
    //  These indicate it's potentially usable but we need info/action from
    //  the user.
    //  
    //  NoAutoMatch   - We got man ids, but didn't find a match for them in
    //                  our current device support. The user needs to select
    //                  something himself, and hopefully help us add support.
    //  WaitDevInfo   - We need the user to tell us the device info because
    //                  the device didn't support querying it.
    //  WaitApprove   - We have gotten man ids and we have support for that
    //                  device, or the user made a selection, but we need
    //                  approval from the user to start using this guy.
    //  
    //  ---------------------------------
    //  These indicate a unit that is ready. When the driver comes up, or after
    //  a replication, if the unit is in GetInitVals() state it is left there. If
    //  it is in ReadyState it is moved to GetInitVals state, so that it will
    //  initially get field values. The same after a replication.
    //  
    //  GetInitVals   - We have device info and so can create our unit object
    //                  and fields and all that.
    //  
    //  Ready         - The unit is ready. It has gotten any initial values it
    //                  can get. Even if all of them weren't gotten, we move to
    //                  ready state and just keep trying. We won't accept any
    //                  client commands for this unit until it gets here.
    //  
    //                  
    // ------------------------------------------------------------------------
    enum class EUnitStates
    {
        Failed
        , Disabled
        , InitUnit
        , GetUnitInfo
        , WaitWakeup
        , GetSecureCls
        , GetManSpec
        , GetName
        , NoAutoMatch
        , WaitDevInfo
        , WaitApprove
        , GetInitVals
        , Ready
        , Count
        , Min = Failed
        , Max = Ready
        , FirstErrState = Failed
        , LastErrState = Disabled
        , FirstViableState = GetUnitInfo
    };
    ZWUSB3SHEXPORT EUnitStates eXlatEUnitStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEUnitStates(const EUnitStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT const TString& strAltXlatEUnitStates(const EUnitStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT EUnitStates eAltXlatEUnitStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EUnitStates eVal);

    
    // ------------------------------------------------------------------------
    //  Used in the methods that CC impls use to report to the base CC Impl
    //  class that the value has changed (and that it in turn passes to a
    //  virtual for others to see.) Values either come from the unit itself
    //  sending us a value, or from the driver (via field writes.)
    //  
    //  We also have 'program' changes, this is mostly where changes in one
    //  impl are being pushed into another.
    //                  
    // ------------------------------------------------------------------------
    enum class EValSrcs
    {
        Unit
        , Driver
        , Program
        , Count
        , Min = Unit
        , Max = Program
    };
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EValSrcs eVal);

    
    // ------------------------------------------------------------------------
    //  The manufacturers we know about, and their Z-Wave assigned ids These should
    //  be in numeric id order. We store names and look them back up, so the binary
    //  order is not important, and this lets us easily binary search by id.
    //                  
    // ------------------------------------------------------------------------
    enum class EZWMakes
    {
        ACT
        , Intermatic
        , Intel
        , WayneDalton
        , Sylvania
        , CasaWorks
        , HomeSeer
        , HomeAutomatedLiving
        , RCS
        , CooperWiringDevices
        , Elk
        , Leviton
        , Carrier
        , Honeywell
        , Allegion
        , Somfy
        , HAI
        , Jasco
        , CooperLighting
        , FortrezZ
        , AeonLabs
        , Kwikset
        , VisionSecurity
        , Fibaro
        , Yale
        , Vesternet
        , EcoLink
        , LinearCorp
        , Inovelli
        , LeakIntel
        , Monoprice
        , StelPro
        , Zooz
        , Evalogik
        , CharmedQuark
        , Count
        , Min = ACT
        , Max = CharmedQuark
    };
    ZWUSB3SHEXPORT EZWMakes eXlatEZWMakes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT const TString& strXlatEZWMakes(const EZWMakes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    ZWUSB3SHEXPORT tCIDLib::TInt4 i4AltNumEZWMakes(const EZWMakes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT EZWMakes eAltNumEZWMakes(const tCIDLib::TInt4 i4Xlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    ZWUSB3SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EZWMakes eVal);

}

#pragma CIDLIB_POPPACK

ZWUSB3SHEXPORT tZWaveUSB3Sh::EAeonMSTypes operator++(tZWaveUSB3Sh::EAeonMSTypes& eVal, int);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::EAeonMSTypes eToStream);

ZWUSB3SHEXPORT tZWaveUSB3Sh::EBinSensorTypes operator++(tZWaveUSB3Sh::EBinSensorTypes& eVal, int);


ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::ECClasses eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::ECClasses& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::ECClasses* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::ECClasses* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tZWaveUSB3Sh::ECClasses operator++(tZWaveUSB3Sh::ECClasses& eVal, int);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::ECClasses eToStream);

ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::EDevTypes eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::EDevTypes& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::EDevTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::EDevTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::EDevTypes eToStream);

ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::EDrvStates eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::EDrvStates& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::EDrvStates* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::EDrvStates* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tZWaveUSB3Sh::EDrvStates operator++(tZWaveUSB3Sh::EDrvStates& eVal, int);

ZWUSB3SHEXPORT tZWaveUSB3Sh::EGenMSTypes operator++(tZWaveUSB3Sh::EGenMSTypes& eVal, int);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::EGenMSTypes eToStream);

ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::EGenTypes eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::EGenTypes& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::EGenTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::EGenTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tZWaveUSB3Sh::EGenTypes operator++(tZWaveUSB3Sh::EGenTypes& eVal, int);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::EGenTypes eToStream);






ZWUSB3SHEXPORT tZWaveUSB3Sh::EThermoModes operator++(tZWaveUSB3Sh::EThermoModes& eVal, int);

ZWUSB3SHEXPORT tZWaveUSB3Sh::EThermoFModes operator++(tZWaveUSB3Sh::EThermoFModes& eVal, int);



constexpr tZWaveUSB3Sh::EUnitAcc operator|(const tZWaveUSB3Sh::EUnitAcc eLHS, const tZWaveUSB3Sh::EUnitAcc eRHS)
{    
    return tZWaveUSB3Sh::EUnitAcc(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
}
constexpr tZWaveUSB3Sh::EUnitAcc& operator|=(tZWaveUSB3Sh::EUnitAcc& eLHS, const tZWaveUSB3Sh::EUnitAcc eRHS)
{    
    eLHS = tZWaveUSB3Sh::EUnitAcc(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
constexpr tZWaveUSB3Sh::EUnitAcc operator&(const tZWaveUSB3Sh::EUnitAcc eLHS, const tZWaveUSB3Sh::EUnitAcc eRHS)
{    
    return tZWaveUSB3Sh::EUnitAcc(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
}
constexpr tZWaveUSB3Sh::EUnitAcc& operator&=(tZWaveUSB3Sh::EUnitAcc& eLHS, const tZWaveUSB3Sh::EUnitAcc eRHS)
{    
    eLHS = tZWaveUSB3Sh::EUnitAcc(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}


ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::EUnitNameSrcs eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::EUnitNameSrcs& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::EUnitNameSrcs* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::EUnitNameSrcs* const aeList, const tCIDLib::TCard4 c4Count);

ZWUSB3SHEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveUSB3Sh::EUnitStates eToStream);
ZWUSB3SHEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tZWaveUSB3Sh::EUnitStates& eToFill);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveUSB3Sh::EUnitStates* const aeList, const tCIDLib::TCard4 c4Count);
ZWUSB3SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveUSB3Sh::EUnitStates* const aeList, const tCIDLib::TCard4 c4Count);


ZWUSB3SHEXPORT tZWaveUSB3Sh::EZWMakes operator++(tZWaveUSB3Sh::EZWMakes& eVal, int);
ZWUSB3SHEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tZWaveUSB3Sh::EZWMakes eToStream);

