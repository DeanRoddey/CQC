// ----------------------------------------------------------------------------
//  FILE: ZWaveLevi2Sh_Shared.hpp
//  DATE: Fri, Feb 12 21:14:16 2021 -0500
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kZWaveLevi2Sh
{
    
    // ------------------------------------------------------------------------
    //  The maximum number of Z-Wave groups that the Z-Wave driver supports.
    //                  
    // ------------------------------------------------------------------------
    constexpr tCIDLib::TCard4 c4MaxGroups = 64;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tZWaveLevi2Sh
{
    
    // ------------------------------------------------------------------------
    //  This is the set of command classes that we currently understand, though not
    //  all of these are actively supported yet. Each unit will store a list of
    //  these, driven by the device info file that the user selects for the unit.
    //  
    //  These are not stored, so you can add new ones in order. The info is reset
    //  upon load of the driver, based on the stored make/model. That's used to look
    //  up the device info object which is stored in the base unit class.
    //                  
    // ------------------------------------------------------------------------
    enum class ECClasses
    {
        None
        , Association
        , Basic
        , Battery
        , BinSensor
        , BinSwitch
        , ColorSwitch
        , Configuration
        , DoorLock
        , Hail
        , Meter
        , MLSensor
        , MLSwitch
        , MultiCmd
        , PowerLevel
        , Naming
        , SceneActuatorConf
        , SceneControllerConf
        , SceneActivation
        , Security
        , SwitchAll
        , ThermoCurTemp
        , ThermoFanMode
        , ThermoFanOpMode
        , ThermoMode
        , ThermoOpMode
        , ThermoSetPnt
        , UserCode
        , Version
        , WakeUp
        , Count
        , Min = None
        , Max = WakeUp
    };
    [[nodiscard]] ZWLEVI2SHEXPORT ECClasses eXlatECClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strXlatECClasses(const ECClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strAltXlatECClasses(const ECClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT ECClasses eAltXlatECClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ECClasses eVal);

    
    // ------------------------------------------------------------------------
    //  The generic types we support so far. This is driven by the info in the device
    //  info file that the user selects for the unit. This is persisted, so new ones
    //  at the end.
    //                  
    // ------------------------------------------------------------------------
    enum class EGenTypes
    {
        None
        , GenCtrl
        , BinSensor
        , BinSwitch
        , EntryCtrl
        , MLSensor
        , MLSwitch
        , Thermo
        , StaticCtrl
        , NotSensor
        , Count
        , Min = None
        , Max = NotSensor
    };
    [[nodiscard]] ZWLEVI2SHEXPORT EGenTypes eXlatEGenTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strXlatEGenTypes(const EGenTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strAltXlatEGenTypes(const EGenTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT EGenTypes eAltXlatEGenTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EGenTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveLevi2Sh::EGenTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tZWaveLevi2Sh::EGenTypes& eToFill)
    {
        eToFill = tZWaveLevi2Sh::EGenTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  When more than one instance of a class exists in a unit, the classes must
    //  be marked to indicate whether they support multi-instance or multi-channel
    //  style interaction. If only one instance it should just be set to Single
    //  (and will be ignored if not.)
    //                  
    // ------------------------------------------------------------------------
    enum class EMultiTypes
    {
        Single
        , Channel
        , Instance
        , Count
        , Min = Single
        , Max = Instance
    };
    [[nodiscard]] ZWLEVI2SHEXPORT EMultiTypes eXlatEMultiTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strXlatEMultiTypes(const EMultiTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strAltXlatEMultiTypes(const EMultiTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT EMultiTypes eAltXlatEMultiTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EMultiTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveLevi2Sh::EMultiTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tZWaveLevi2Sh::EMultiTypes& eToFill)
    {
        eToFill = tZWaveLevi2Sh::EMultiTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  The multi-level sensor can support a bunch of types. We support a small set currently. We
    //  create this enum so that these ordinals match the Z-Wave defined numbers, and we provide
    //  a short name for each one in the alt text that is used when creating field names where
    //  appropriate.
    //                  
    // ------------------------------------------------------------------------
    enum class EMLSensTypes
    {
        None
        , Temp
        , Gen
        , Lum
        , Power
        , Hum
        , Count
        , Min = None
        , Max = Hum
    };
    [[nodiscard]] ZWLEVI2SHEXPORT EMLSensTypes eXlatEMLSensTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strXlatEMLSensTypes(const EMLSensTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strAltXlatEMLSensTypes(const EMLSensTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT EMLSensTypes eAltXlatEMLSensTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT tCIDLib::TBoolean bIsValidEnum(const EMLSensTypes eVal);

    inline TBinOutStream& operator<<(TBinOutStream& strmTar, const tZWaveLevi2Sh::EMLSensTypes eVal)
    {
        strmTar.WriteEnum(tCIDLib::TCard4(eVal));
        return strmTar;
    }
    inline TBinInStream& operator>>(TBinInStream& strmSrc, COP tZWaveLevi2Sh::EMLSensTypes& eToFill)
    {
        eToFill = tZWaveLevi2Sh::EMLSensTypes(strmSrc.c4ReadEnum());
        return strmSrc;
    }
    
    // ------------------------------------------------------------------------
    //  The various specific types that a device may indicate. If not specified, then it
    //  will be set to None. Some of these may not map to actual Z-Wave speicifc types, but
    //  just tell us what we want to know.
    //                  
    // ------------------------------------------------------------------------
    enum class ESpecTypes
    {
        None
        , PowerBinSwitch
        , PowerMLSwitch
        , SceneBinSwitch
        , SceneMLSwitch
        , ThermoV2
        , VRCOP
        , Count
        , Min = None
        , Max = VRCOP
    };
    [[nodiscard]] ZWLEVI2SHEXPORT ESpecTypes eXlatESpecTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strXlatESpecTypes(const ESpecTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT const TString& strAltXlatESpecTypes(const ESpecTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    [[nodiscard]] ZWLEVI2SHEXPORT ESpecTypes eAltXlatESpecTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    [[nodiscard]] ZWLEVI2SHEXPORT tCIDLib::TBoolean bIsValidEnum(const ESpecTypes eVal);

}

#pragma CIDLIB_POPPACK


ZWLEVI2SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveLevi2Sh::EGenTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWLEVI2SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveLevi2Sh::EGenTypes* const aeList, const tCIDLib::TCard4 c4Count);

ZWLEVI2SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveLevi2Sh::EMultiTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWLEVI2SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveLevi2Sh::EMultiTypes* const aeList, const tCIDLib::TCard4 c4Count);

ZWLEVI2SHEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tZWaveLevi2Sh::EMLSensTypes* const aeList, const tCIDLib::TCard4 c4Count);
ZWLEVI2SHEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tZWaveLevi2Sh::EMLSensTypes* const aeList, const tCIDLib::TCard4 c4Count);


