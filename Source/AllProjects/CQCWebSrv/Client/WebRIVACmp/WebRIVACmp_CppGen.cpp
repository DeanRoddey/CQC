//
// FILE NAME: WebRIVACmp_CppGen.cpp
//
// AUTHOR: Dean Roddey
//
// CREATED: 05/30/2017
//
// COPYRIGHT: Charmed Quark Systems, Ltd @ 2020
//
//  This software is copyrighted by 'Charmed Quark Systems, Ltd' and 
//  the author (Dean Roddey.) It is licensed under the MIT Open Source 
//  license:
//
//  https://opensource.org/licenses/MIT
//
// DESCRIPTION:
//
//  This class takes the root element of the XML tree and does the generation for
//  the C++ side.
//
// CAVEATS/GOTCHAS:
//
// LOG:
//
//  $Log$
//


// ---------------------------------------------------------------------------
//  Includes
// ---------------------------------------------------------------------------
#include "WebRIVACmp.hpp"



// ---------------------------------------------------------------------------
//   CLASS: TCppGenerator
//  PREFIX: gen
// ---------------------------------------------------------------------------

// --------------------------------------------------------------------
//  TCppGenerator: Constructors and Destructor
// --------------------------------------------------------------------
TCppGenerator::TCppGenerator()
{
}


TCppGenerator::~TCppGenerator()
{
}


// --------------------------------------------------------------------
//  TCppGenerator: Public, non-virtual methods
// --------------------------------------------------------------------
tCIDLib::TVoid TCppGenerator::GenerateOutput(const TXMLTreeElement& xtnodeRoot)
{

    TPathStr pathSrc = TProcEnvironment::strFind(L"CQC_SRCTREE");
    pathSrc.AddLevel(L"Source");
    pathSrc.AddLevel(L"AllProjects");

    TPathStr pathHpp(pathSrc);
    pathHpp.AddLevel(L"CQCWebSrv");
    pathHpp.AddLevel(L"Client");

    TPathStr pathHelpers(pathHpp);
    pathHelpers.AddLevel(L"WebRIVACmp");
    pathHelpers.AddLevel(L"WebRIVACmp_Helpers.Txt");

    TPathStr pathHelpers2(pathHpp);
    pathHelpers2.AddLevel(L"WebRIVACmp");
    pathHelpers2.AddLevel(L"WebRIVACmp_Helpers2.Txt");

    pathHpp.AddLevel(L"CQCWebRIVA");
    TPathStr pathCpp(pathHpp);
    pathHpp.AddLevel(L"CQCWebRIVA_Proto.hpp");
    pathCpp.AddLevel(L"CQCWebRIVA_Proto.cpp");

    // And let's create output streams for those
    m_strmCpp.Open
    (
        pathCpp
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    m_strmHpp.Open
    (
        pathHpp
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
        , tCIDLib::EAccessModes::Excl_Write
    );

    //
    //  Output the opening stuff in each file
    //
    TTime tmNow(tCIDLib::ESpecialTimes::CurrentTime);
    tmNow.strDefaultFormat(TTime::strCTime());
    m_strmHpp   << L"// -----------------------------------------\n"
                   L"//  Generated by WebRIVACmp (" << tmNow << L")\n"
                   L"// -----------------------------------------\n"
                   L"#pragma once\n\n";


    m_strmCpp << L"// -----------------------------------------\n"
                 L"//  Generated by WebRIVACmp (" << tmNow << L")\n"
              << L"// -----------------------------------------\n\n"
                 L"#include \"CQCWebRIVA_.hpp\"\n\n";


    //
    //  Spit out some helper code to the Cpp file, which are used internally by the
    //  generated methods. We keep it in a separate file, so read it in.
    //
    {
        TTextFileInStream strmHelpers
        (
            pathHelpers
            , tCIDLib::ECreateActs::OpenIfExists
            , tCIDLib::EFilePerms::Default
            , tCIDLib::EFileFlags::SequentialScan
            , tCIDLib::EAccessModes::Excl_Read
        );

        TString strLn;
        while (!strmHelpers.bEndOfStream())
        {
            strmHelpers >> strLn;
            m_strmCpp << strLn << kCIDLib::NewLn;
        }
        m_strmCpp << L"\n\n";
    }


    // Spit out the constants, which are only in the header and in a constants namespace
    {
        m_strmHpp << L"namespace kWebRIVA\n{\n";
        const TXMLTreeElement& xtnodeConstants = xtnodeRoot.xtnodeChildAtAsElement(0);
        const tCIDLib::TCard4 c4Count = xtnodeConstants.c4ChildCount();
        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
        {
            const TXMLTreeElement& xtnodeCur = xtnodeConstants.xtnodeChildAtAsElement(c4Index);
            const TString& strName = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
            const TString& strType = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrType).strValue();
            const TString& strVal = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrVal).strValue();

            // Translate the type to an enum
            const tWebRIVACmp::EConstTypes eType = tWebRIVACmp::eXlatEConstTypes(strType);

            // Spit out the name, adjust to C++ specs
            m_strmHpp << L"    const ";
            if (eType == tWebRIVACmp::EConstTypes::String)
                m_strmHpp << L"TString";
            else
                m_strmHpp << L"tCIDLib::T" << strType;
            m_strmHpp << L" ";

            // Use the enum generate the correct C++ type prefix for the name
            m_strmHpp << tWebRIVACmp::strAltXlatEConstTypes(eType)
                      << strName << L" = ";

            if (eType == tWebRIVACmp::EConstTypes::String)
                m_strmHpp << L"L\"" << strVal << L"\"";
            else
                m_strmHpp << strVal;

            m_strmHpp << L";\n";
        }
        m_strmHpp << L"\n}\n\n";
    }

    //
    //  Spit out the enums which are also only in the header
    {
        TString strVal;

        m_strmHpp << L"namespace tWebRIVA\n{\n";
        const TXMLTreeElement& xtnodeEnums = xtnodeRoot.xtnodeChildAtAsElement(1);
        const tCIDLib::TCard4 c4Count = xtnodeEnums.c4ChildCount();
        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
        {
            const TXMLTreeElement& xtnodeCur = xtnodeEnums.xtnodeChildAtAsElement(c4Index);
            const TString& strEName = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
            m_strmHpp   << L"    enum class E" << strEName << L"s\n    {\n";

            // Iterate the the values for this enumeration
            const tCIDLib::TCard4 c4ValCnt = xtnodeCur.c4ChildCount();
            for (tCIDLib::TCard4 c4Index = 0; c4Index < c4ValCnt; c4Index++)
            {
                const TXMLTreeElement& xtnodeVal = xtnodeCur.xtnodeChildAtAsElement(c4Index);
                const TString& strVName = xtnodeVal.xtattrNamed(kWebRIVACmp::strAttrName).strValue();

                m_strmHpp << L"        ";
                if (c4Index)
                    m_strmHpp << kWebRIVACmp::strVal_LineSep;

                m_strmHpp << strVName;

                // If it has an explicit value, set that
                if (xtnodeVal.bAttrExists(kWebRIVACmp::strAttrVal, strVal))
                    m_strmHpp << L" = " << strVal;

                m_strmHpp << kCIDLib::NewLn;
            }
            m_strmHpp   << L"    };\n\n";
        }
        m_strmHpp << L"\n}\n\n";
    }

    //
    //  Do the structures, which are defined in the header, then we need to generate the
    //  appropriate translation methods, based on the direction. Then generate the translation
    //  methods into the Cpp file.
    //
    {
        m_strmHpp   << L"class CQCWEBRIVAEXP TWebRIVATools\n{\n"
                       L"    public :\n"
                       L"        TWebRIVATools();\n"
                       L"        ~TWebRIVATools();\n\n"
                       L"       tCIDLib::TVoid ThrowBadOpExtract(const tWebRIVA::EOpCodes eGot, const tWebRIVA::EOpCodes eExpected);\n\n";


        m_strmCpp   << L"TWebRIVATools::TWebRIVATools() : \n"
                       L"    m_strmFmt(8192, 0x100000, new TUTF8Converter)\n{\n}\n\n"
                       L"TWebRIVATools::~TWebRIVATools()\n{\n}\n\n";

        const TXMLTreeElement& xtnodeStructs = xtnodeRoot.xtnodeChildAtAsElement(2);
        const tCIDLib::TCard4 c4StructCnt = xtnodeStructs.c4ChildCount();
        for (tCIDLib::TCard4 c4Index = 0; c4Index < c4StructCnt; c4Index++)
        {
            const TXMLTreeElement& xtnodeCur = xtnodeStructs.xtnodeChildAtAsElement(c4Index);
            const TString& strDir = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrDir).strValue();
            const TString& strType = xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrType).strValue();

            //
            //  If this one is server to client, then we need to generate a method to
            //  spit it out into JSON form. If it's client to server, we need to generate
            //  a method to extract the values from the received JSON.
            //
            if (strDir.bCompareI(kWebRIVACmp::strAttrDirSC)
            ||  strDir.bCompareI(kWebRIVACmp::strAttrDirBoth))
            {
                GenSCMethod(strType, xtnodeCur);
            }

            if (strDir.bCompareI(kWebRIVACmp::strAttrDirCS)
            ||  strDir.bCompareI(kWebRIVACmp::strAttrDirBoth))
            {
                GenCSMethod(strType, xtnodeCur);
            }
        }

        //
        //  Spit out some helper methods that make some of the generated ones easier
        //  to use. Output the header stuff
        //
        m_strmHpp   << L"\n\n        // Convenience methods\n"
                       L"        TMemBuf* pmbufFormatShowException\n"
                       L"        (\n"
                       L"                    tCIDLib::TCard4&  c4Bytes\n"
                       L"            , const TString&          strTitle\n"
                       L"            , const TString&          strMsgText\n"
                       L"            , const TError&           errToSend\n"
                       L"        );\n\n";

        // The body content is in a separate txt file, so read it in and output it
        {
            TTextFileInStream strmHelpers2
            (
                pathHelpers2
                , tCIDLib::ECreateActs::OpenIfExists
                , tCIDLib::EFilePerms::Default
                , tCIDLib::EFileFlags::SequentialScan
                , tCIDLib::EAccessModes::Excl_Read
            );

            TString strLn;
            while (!strmHelpers2.bEndOfStream())
            {
                strmHelpers2 >> strLn;
                m_strmCpp << strLn << kCIDLib::NewLn;
            }
        }

        // Declare our members, and close off the class in the header
        m_strmHpp   << L"    private :\n"
                       L"        TTextMBufOutStream m_strmFmt;\n"
                       L"\n};\n\n";
    }

    m_strmCpp.Flush();
    m_strmHpp.Flush();
}


// --------------------------------------------------------------------
//  TCppGenerator: Private, non-virtual methods
// --------------------------------------------------------------------

//
//  WE get the type of the passed structure member node and translate it to our structure
//  member type enum. We then use that to output the actual type name to the passed
//  target stream.
//
tWebRIVACmp::EMemTypes
TCppGenerator::eFormatStructMemType(        TTextOutStream&     strmTar
                                    , const TXMLTreeElement&    xtnodeSrc)
{
    // Translate the type name to our mapping enum
    tWebRIVACmp::EMemTypes eType = tWebRIVACmp::eXlatEMemTypes
    (
        xtnodeSrc.xtattrNamed(kWebRIVACmp::strAttrType).strValue()
    );

    // Some are convenient alternative names, so force them to their actual type
    if (eType == tWebRIVACmp::EMemTypes::Opacity)
        eType = tWebRIVACmp::EMemTypes::Card1;

    if (eType == tWebRIVACmp::EMemTypes::Enum)
    {
        // We have to get the actual type from the structure
        strmTar << L"tWebRIVA::E"
                << xtnodeSrc.xtattrNamed(kWebRIVACmp::strAttrEnumType).strValue();
    }
     else
    {
        // For anything else the actual type is in the alt text 2 value
        strmTar << tWebRIVACmp::strAltXlat2EMemTypes(eType);
    }

    return eType;
}


//
//  We get the overall structures element so that we can look up referenced sub-structures
//  as required.
//
tCIDLib::TVoid
TCppGenerator::GenCSMethod( const   TString&            strType
                            , const TXMLTreeElement&    xtnodeStruct)
{
    //
    //  Generate the function definition in the header
    //
    m_strmHpp   << L"        tCIDLib::TVoid Extract" << strType << L"\n        (\n";

    // Do the implied opcode and sequence id parameters and JSON parser
    m_strmHpp   << L"                    TJSONObject&           jprsnSrc";

    tCIDLib::TCard4 c4Count = xtnodeStruct.c4ChildCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);

        m_strmHpp << L"\n            ,       ";

        // Output the actual C++ type for this member
        const tWebRIVACmp::EMemTypes eType = eFormatStructMemType(m_strmHpp, xtnodeCur);

        // These are alll output params s we need a reference
        m_strmHpp   << L"&   "
                    << tWebRIVACmp::strAltXlatEMemTypes(eType)
                    << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
    }
    m_strmHpp << L"\n        );\n\n";


    //
    //  Now generate the code to the Cpp file, to do the extraction
    //
    m_strmCpp << L"tCIDLib::TVoid\nTWebRIVATools::Extract" << strType << L"(";
    const tCIDLib::TCard4 c4IndentLen = 21 + strType.c4Length();

    // Do the implied opcode and sequence id parameters and source JSON object
    m_strmCpp   << L"TJSONObject& jprsnSrc";

    c4Count = xtnodeStruct.c4ChildCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);
        m_strmCpp   << L"\n" << TTextOutStream::Spaces(c4IndentLen)
                    << kWebRIVACmp::strVal_LineSep;

        // Output the actual C++ type for this member
        const tWebRIVACmp::EMemTypes eType = eFormatStructMemType(m_strmCpp, xtnodeCur);

        // These are all output parameters so we need a reference
        m_strmCpp   << L"&    "
                    << tWebRIVACmp::strAltXlatEMemTypes(eType)
                    << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
    }

    // Now close off the params and open the body so we can generate the code
    m_strmCpp << L")\n{\n";

    //
    //  Now, based on the type of the parameter, we do the correct thing to exract the
    //  value. For the object type ones, we can just call a parse method on those objects
    //  since our protocol's format uses the format they define.
    //
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);
        const tWebRIVACmp::EMemTypes eType = tWebRIVACmp::eXlatEMemTypes
        (
            xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrType).strValue()
        );

        switch(eType)
        {
            case tWebRIVACmp::EMemTypes::Boolean :
                m_strmCpp   << L"    b"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L" = bExtractBool(jprsnSrc, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;

            case tWebRIVACmp::EMemTypes::Card1 :
            case tWebRIVACmp::EMemTypes::Card2 :
            case tWebRIVACmp::EMemTypes::Card4 :
            case tWebRIVACmp::EMemTypes::Card8 :
            case tWebRIVACmp::EMemTypes::Float8 :
            case tWebRIVACmp::EMemTypes::Int1 :
            case tWebRIVACmp::EMemTypes::Int2 :
            case tWebRIVACmp::EMemTypes::Int4 :
            case tWebRIVACmp::EMemTypes::Int8 :
            {
                m_strmCpp   << L"    " << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L" = " << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << L"ExtractNum(jprsnSrc, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            case tWebRIVACmp::EMemTypes::AlphaColor :
            case tWebRIVACmp::EMemTypes::Color :
            {
                m_strmCpp   << L"    ExtractColor(jprsnSrc, clr"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            case tWebRIVACmp::EMemTypes::Area :
            {
                m_strmCpp   << L"    ExtractArea(jprsnSrc, area"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            case tWebRIVACmp::EMemTypes::Enum :
            {
                m_strmCpp   << L"    e"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L" = tWebRIVA::E"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrEnumType).strValue()
                            << L"(i4ExtractNum(jprsnSrc, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L"))";
                break;
            }

            case tWebRIVACmp::EMemTypes::Point :
            {
                m_strmCpp   << L"    ExtractPoint(jprsnSrc, pnt"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            case tWebRIVACmp::EMemTypes::Size :
            {
                m_strmCpp   << L"    ExtractSize(jprsnSrc, sz"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            case tWebRIVACmp::EMemTypes::String :
            {
                m_strmCpp   << L"    str"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L" = jprsnSrc.strValByName(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L")";
                break;
            }

            default :
                CIDAssert2(L"Unknown parameter type in Cpp file generation");
                break;
        };

        m_strmCpp << L";\n";
    }

    // And close off the body and we are done with this one
    m_strmCpp << L"}\n\n";
}

tCIDLib::TVoid
TCppGenerator::GenSCMethod( const   TString&            strType
                            , const TXMLTreeElement&    xtnodeStruct)
{
    //
    //  Generate the function definition in the header
    //
    m_strmHpp   << L"        TMemBuf* pmbufFormat" << strType << L"\n        (\n"
                << L"                    tCIDLib::TCard4&   c4Bytes";

    const tCIDLib::TCard4 c4Count = xtnodeStruct.c4ChildCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);
        m_strmHpp << L"\n            , const ";

        // Output the actual C++ type for this member
        const tWebRIVACmp::EMemTypes eType = eFormatStructMemType(m_strmHpp, xtnodeCur);

        //  If an object type it has to be by reference.
        if (eType > tWebRIVACmp::EMemTypes::Enum)
            m_strmHpp << L"&   ";
        else
            m_strmHpp << L"    ";

        m_strmHpp   << tWebRIVACmp::strAltXlatEMemTypes(eType)
                    << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
    }
    m_strmHpp << L"\n        );\n\n";


    //
    //  Now generate the code to the Cpp file
    //
    const tCIDLib::TCard4 c4IndentLen = 20 + strType.c4Length();
    m_strmCpp << L"TMemBuf*\nTWebRIVATools::pmbufFormat" << strType << L"(\n"
              << TTextOutStream::Spaces(c4IndentLen) << L"        tCIDLib::TCard4&   c4RetSz";
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);
        m_strmCpp << L"\n" << TTextOutStream::Spaces(c4IndentLen) << L", const ";

        // Output the actual C++ type for this member
        const tWebRIVACmp::EMemTypes eType = eFormatStructMemType(m_strmCpp, xtnodeCur);

        // If an object we need a reference
        if (eType > tWebRIVACmp::EMemTypes::Enum)
            m_strmCpp << L"&    ";
        else
            m_strmCpp << L"    ";

        m_strmCpp   << tWebRIVACmp::strAltXlatEMemTypes(eType)
                    << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
    }

    m_strmCpp << L")\n{\n"
                 L"    m_strmFmt.Reset();\n"
                 L"    m_strmFmt << kCIDLib::chOpenBrace << kCIDLib::NewLn;\n";

    // The opcode goes first, which we can figure out ourself, so it's not passed in
    m_strmCpp   << L"    TJSONParser::OutputInt(kWebRIVA::strAttr_OpCode, "
                   L"tCIDLib::TInt4(tWebRIVA::EOpCodes::" << strType << L"), m_strmFmt";
    if (!c4Count)
        m_strmCpp << L", kCIDLib::True";
    m_strmCpp   << L");\n";

    //
    //  And now do the rest of them. For the objects we need to format them out to text.
    //  For the others, we can just format them out ourself.
    //
    TString strVal;
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        const TXMLTreeElement& xtnodeCur = xtnodeStruct.xtnodeChildAtAsElement(c4Index);
        const tWebRIVACmp::EMemTypes eType = tWebRIVACmp::eXlatEMemTypes
        (
            xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrType).strValue()
        );

        switch(eType)
        {
            case tWebRIVACmp::EMemTypes::Boolean :
            {
                m_strmCpp   << L"    TJSONParser::OutputBool(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", b"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::Card1 :
            case tWebRIVACmp::EMemTypes::Card2 :
            case tWebRIVACmp::EMemTypes::Card4 :
            case tWebRIVACmp::EMemTypes::Card8 :
            {
                m_strmCpp   << L"    TJSONParser::OutputCard(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << kWebRIVACmp::strVal_LineSep
                            << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::Int1 :
            case tWebRIVACmp::EMemTypes::Int2 :
            case tWebRIVACmp::EMemTypes::Int4 :
            case tWebRIVACmp::EMemTypes::Int8 :
            {
                m_strmCpp   << L"    TJSONParser::OutputInt(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << kWebRIVACmp::strVal_LineSep
                            << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::Enum :
            {
                m_strmCpp   << L"    TJSONParser::OutputInt(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << kWebRIVACmp::strVal_LineSep
                            << L"tCIDLib::TInt4("
                            << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L")"
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::Float8 :
            {
                m_strmCpp   << L"    TJSONParser::OutputFloat(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << kWebRIVACmp::strVal_LineSep
                            << tWebRIVACmp::strAltXlatEMemTypes(eType)
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::AlphaColor :
            case tWebRIVACmp::EMemTypes::Color :
            {
                m_strmCpp   << L"    FormatClr(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", clr"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                if (eType == tWebRIVACmp::EMemTypes::AlphaColor)
                    m_strmCpp << kWebRIVACmp::strVal_CommaTrue;
                else
                    m_strmCpp << kWebRIVACmp::strVal_CommaFalse;
                break;
            }

            case tWebRIVACmp::EMemTypes::Area :
            {
                m_strmCpp   << L"    FormatArea(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", area"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                break;
            }

            case tWebRIVACmp::EMemTypes::Point :
            {
                m_strmCpp   << L"    FormatPoint(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", pnt"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                break;
            }

            case tWebRIVACmp::EMemTypes::Size :
            {
                m_strmCpp   << L"    FormatSize(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", sz"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                break;
            }

            case tWebRIVACmp::EMemTypes::String :
            {
                m_strmCpp   << L"    TJSONParser::OutputStr(kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", str"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue()
                            << L", m_strmFmt";
                break;
            }

            case tWebRIVACmp::EMemTypes::Passthrough :
            {
                m_strmCpp   << L"    FormatPassthrough(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", str"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                break;
            }

            //
            //  We have a special one for opacities. They are Card1 values, but we have
            //  to translate them to a float.
            //
            case tWebRIVACmp::EMemTypes::Opacity :
            {
                m_strmCpp   << L"    FormatOpacity(m_strmFmt, kWebRIVA::strAttr_"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrAName).strValue()
                            << L", c1"
                            << xtnodeCur.xtattrNamed(kWebRIVACmp::strAttrName).strValue();
                break;
            }

            default :
                CIDAssert2(L"Unknown parameter type in Cpp file generation");
                break;
        };

        // If this is the last one output true as the last parameter
        if (c4Index + 1 >= c4Count)
            m_strmCpp << kWebRIVACmp::strVal_CommaTrue;

        // And close off the method call
        m_strmCpp << L");\n";
    }

    // Output the code to close off the JSON object
    m_strmCpp << L"    m_strmFmt << kCIDLib::chCloseBrace << kCIDLib::NewLn;\n";

    //
    //  Flush the target stream, allocate a buffer big enough to hold the results and
    //  copy it over.
    //
    m_strmCpp   << L"    m_strmFmt.Flush();\n"
                   L"    c4RetSz = m_strmFmt.c4CurSize();\n"
                << L"    return new THeapBuf(m_strmFmt.mbufData(), c4RetSz, c4RetSz);\n"
                << L"}\n\n";
}
