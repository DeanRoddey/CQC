// ----------------------------------------------------------------------------
//  FILE: CQCMedia_Shared.hpp
//  DATE: Fri, Feb 14 18:49:45 2020 -0500
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kCQCMedia
{
    
    // ------------------------------------------------------------------------
    //  Some media repositories will add some special categories. These
    //  are the ids used for them. We also define a safe place to start
    //  assigning dynamically defined category ids, which leaves a few
    //  more slots for special categories. These can never change.
    //                  
    // ------------------------------------------------------------------------
    constexpr tCIDLib::TCard2 c2CatId_Unknown = 0;
    constexpr tCIDLib::TCard4 c2CatId_AllMovies = 1;
    constexpr tCIDLib::TCard4 c2CatId_AllMusic = 2;
    constexpr tCIDLib::TCard4 c2CatId_AllPictures = 3;
    constexpr tCIDLib::TCard4 c2CatId_PlayLists = 4;
    constexpr tCIDLib::TCard4 c2CatId_UserStart = 10;
    
    // ------------------------------------------------------------------------
    //  This is used by standard renderer drivers to prefix the value that
    //  they put into their playlist item key field. This tells the client
    //  that the info is in standard format and therefore can be parsed to
    //  get out useful information. It will be in the form:
    //  
    //      StdPLItemKey:moniker cookie Lrg|Sml
    //  
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strRend_StdPLItemKeyPref;
    
    // ------------------------------------------------------------------------
    //  Some of the 'backdoor' driver interfaces (i.e. non-field oriented) are
    //  used by media clients to get info from media drivers and to get them
    //  to do things. These aren't persisted.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strQuery_CatList;
    CQCMEDIAEXPORT const extern TString strQuery_ColItems;
    CQCMEDIAEXPORT const extern TString strQuery_TitleDetails;
    CQCMEDIAEXPORT const extern TString strQuery_OTFTitleList;
    CQCMEDIAEXPORT const extern TString strQuery_ColDetails;
    CQCMEDIAEXPORT const extern TString strQuery_ItemDetails;
    CQCMEDIAEXPORT const extern TString strQuery_DefCatInfo;
    CQCMEDIAEXPORT const extern TString strQuery_MediaFmt;
    CQCMEDIAEXPORT const extern TString strQuery_DBSerialNumber;
    CQCMEDIAEXPORT const extern TString strQuery_Artist;
    CQCMEDIAEXPORT const extern TString strQuery_AspectRatio;
    CQCMEDIAEXPORT const extern TString strQuery_Cast;
    CQCMEDIAEXPORT const extern TString strQuery_Description;
    CQCMEDIAEXPORT const extern TString strQuery_Label;
    CQCMEDIAEXPORT const extern TString strQuery_LeadActor;
    CQCMEDIAEXPORT const extern TString strQuery_Rating;
    CQCMEDIAEXPORT const extern TString strQuery_RawRunTime;
    CQCMEDIAEXPORT const extern TString strQuery_RunTime;
    CQCMEDIAEXPORT const extern TString strQuery_Title;
    CQCMEDIAEXPORT const extern TString strQuery_Year;
    CQCMEDIAEXPORT const extern TString strQuery_CookieLookup;
    CQCMEDIAEXPORT const extern TString strQuery_RandomGenreItems;
    CQCMEDIAEXPORT const extern TString strQuery_BitDepth;
    CQCMEDIAEXPORT const extern TString strQuery_BitRate;
    CQCMEDIAEXPORT const extern TString strQuery_Channels;
    CQCMEDIAEXPORT const extern TString strQuery_DateAdded;
    CQCMEDIAEXPORT const extern TString strQuery_SampleRate;
    CQCMEDIAEXPORT const extern TString strQuery_SeqNum;
    CQCMEDIAEXPORT const extern TString strQuery_UserRating;
    CQCMEDIAEXPORT const extern TString strQuery_QueryAudioFmt;
    CQCMEDIAEXPORT const extern TString strQuery_Name;
    CQCMEDIAEXPORT const extern TString strQuery_CurPLItem;
    CQCMEDIAEXPORT const extern TString strQuery_PLItems;
    CQCMEDIAEXPORT const extern TString strQuery_BinMediaDump;
    CQCMEDIAEXPORT const extern TString strQuery_XMLMediaDump;
    CQCMEDIAEXPORT const extern TString strQuery_QueryCurPLItemId;
    
    // ------------------------------------------------------------------------
    //  Some of the 'backdoor' driver interfaces (i.e. non-field oriented) are
    //  used by media clients to get info from media drivers and to get them
    //  to do things. These take a Card4 value as an 'value id' that indicates
    //  what value to return.
    //  
    //  All of these use the 'QueryCardVal' or 'QueryIntVal' APIs, which just
    //  get a single signed or unsigned value from the driver.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strQuery_ProtoVer;
    CQCMEDIAEXPORT const extern TString strQuery_MediaTypes;
    CQCMEDIAEXPORT const extern TString strQuery_ColLoc;
    
    // ------------------------------------------------------------------------
    //  These use another backdoor call that returns a memory buffer of data,
    //  and can be used to return image data and so forth. For art queries
    //  the values are:
    //  
    //  QArt      - A flattened JPEG, PNG, or bitmap image, according to
    //              what the repository provides. A collection cookie is passed,
    //              so this returns a specific collection's art.
    //  QItemArt  - Same as QueryArt, but indicates we want item art if it is
    //              available, else the collection art will be returned.
    //  QTitleArt - Same as QueryArt, but indicates we want title level art
    //              if available, else the art of the first collection that
    //              has any. In this case, a title cookie is passed
    //  
    //  QThumbItemArt
    //  QThumbTitleArt
    //  QThumbArt - Same as above but asks for the thumbnail versions of the
    //              image.
    //  
    //  QPosterArt- Queries poster art if available.
    //  
    //  All of the above have to provide a title, collection, or item cookie.
    //  The server will try to do its best to return what was asked for given
    //  the request and the cookie provided.
    //  
    //  
    //  QImgById  - Used by the client service, for caching art locally by
    //              peristent id. In this case no cookie is needed, since
    //              it's directly passing a unique art id.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strQuery_QueryArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryTitleArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryItemArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryThumbArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryTitleThumbArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryItemThumbArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryPosterArt;
    CQCMEDIAEXPORT const extern TString strQuery_QueryImgById;
    
    // ------------------------------------------------------------------------
    //  Commands that some media repo drivers support.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strCmd_SetUserRating;
    
    // ------------------------------------------------------------------------
    //  Action events that are specific to the media subsystem. Most of them
    //  are generic and defined in CQCKit.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strEvId_OnSelectCol;
    CQCMEDIAEXPORT const extern TString strEvId_OnSelectItem;
    
    // ------------------------------------------------------------------------
    //  These are unique ids for all the CQC action commands that are media related.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strCmdId_SetCategory;
    CQCMEDIAEXPORT const extern TString strCmdId_SetTitle;
    CQCMEDIAEXPORT const extern TString strCmdId_SetTitleCookie;
    CQCMEDIAEXPORT const extern TString strCmdId_SetMediaType;
    CQCMEDIAEXPORT const extern TString strCmdId_SetSortOrder;
    CQCMEDIAEXPORT const extern TString strCmdId_SetColCookie;
    CQCMEDIAEXPORT const extern TString strCmdId_GetColLocInfo;
    CQCMEDIAEXPORT const extern TString strCmdId_GetItemLocInfo;
    CQCMEDIAEXPORT const extern TString strCmdId_GetSortOrder;
    CQCMEDIAEXPORT const extern TString strCmdId_SearchByArtist;
    CQCMEDIAEXPORT const extern TString strCmdId_SetRepository;
    CQCMEDIAEXPORT const extern TString strCmdId_GetCatCookie;
    CQCMEDIAEXPORT const extern TString strCmdId_SetTextType;
    CQCMEDIAEXPORT const extern TString strCmdId_SearchByTitle;
    CQCMEDIAEXPORT const extern TString strCmdId_SearchByActor;
    CQCMEDIAEXPORT const extern TString strCmdId_GetMediaType;
    CQCMEDIAEXPORT const extern TString strCmdId_GetAudioFmt;
    CQCMEDIAEXPORT const extern TString strCmdId_SearchByAudioFmt;
    CQCMEDIAEXPORT const extern TString strCmdId_RandomTitleSearch;
    
    // ------------------------------------------------------------------------
    //  These are unique ids for various command runtime values supported at the user
    //  interface level.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strRTVId_CategoryCookie;
    CQCMEDIAEXPORT const extern TString strRTVId_Artist;
    CQCMEDIAEXPORT const extern TString strRTVId_CategoryName;
    CQCMEDIAEXPORT const extern TString strRTVId_ColArtist;
    CQCMEDIAEXPORT const extern TString strRTVId_ColCookie;
    CQCMEDIAEXPORT const extern TString strRTVId_ColCount;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemArtist;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemArtistList;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemCookie;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemCookieList;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemName;
    CQCMEDIAEXPORT const extern TString strRTVId_ItemNameList;
    CQCMEDIAEXPORT const extern TString strRTVId_LocInfo;
    CQCMEDIAEXPORT const extern TString strRTVId_LocType;
    CQCMEDIAEXPORT const extern TString strRTVId_MediaType;
    CQCMEDIAEXPORT const extern TString strRTVId_TitleArtist;
    CQCMEDIAEXPORT const extern TString strRTVId_TitleCookie;
    CQCMEDIAEXPORT const extern TString strRTVId_TitleCount;
    CQCMEDIAEXPORT const extern TString strRTVId_TitleName;
    CQCMEDIAEXPORT const extern TString strRTVId_TitleNumber;
    CQCMEDIAEXPORT const extern TString strRTVId_MediaRepoMoniker;
    CQCMEDIAEXPORT const extern TString strRTVId_MediaFmt;
    CQCMEDIAEXPORT const extern TString strRTVId_Name;
    CQCMEDIAEXPORT const extern TString strRTVId_TopLevel;
    CQCMEDIAEXPORT const extern TString strRTVId_ListItemId;
    
    // ------------------------------------------------------------------------
    //  These are required names for some fields that media repository
    //  drivers must provide. This insures some consistency among
    //  media repository drivers, so that clients can interact with
    //  them in a more generic way.
    //                  
    // ------------------------------------------------------------------------
    CQCMEDIAEXPORT const extern TString strMediaFld_DBSerialNum;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tCQCMedia
{
    
    // ------------------------------------------------------------------------
    //  Used in some cookie parsing/formatting helper methods. Keep the c4MaxCookieTokens
    //  value in the constants namespace up to date if you change this enum!
    //                  
    // ------------------------------------------------------------------------
    enum class ECookieTypes
    {
        Cat
        , Title
        , Collect
        , Item
        , Count
        , Min = Cat
        , Max = Item
    };
    CQCMEDIAEXPORT ECookieTypes eXlatECookieTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatECookieTypes(const ECookieTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ECookieTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in some of the cursor creation methods of the database class. It
    //  indicates how to interpret the target values. Should we find stuff less
    //  than, greater than, equal, and combinations thereof.
    //  
    //  Note that values work out to make it reasonably efficient to do a comparison
    //  for the lteq and gteq types. If we just add one and treat the result
    //  as a bit mask. Then Eq becomes 1, Lt is 10 and LtEq is 11 (i.e. Lt plus Eq
    //  masks). Gt is 100 so gt without equal, and GtEq is 101 or Gt plus Eq.
    //  
    //  So anything with a one bit on in the mask includes equality. Anything
    //  with a two bit on includes Lt, anything with a three bit on includes
    //  gt.
    //  
    //  The text needs to be inline since we use it in action command parameters.
    //                  
    // ------------------------------------------------------------------------
    enum class ECompTypes
    {
        Eq
        , Lt
        , LtEq
        , Gt
        , GtEq
        , Count
        , Min = Eq
        , Max = GtEq
    };
    CQCMEDIAEXPORT ECompTypes eXlatECompTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatECompTypes(const ECompTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ECompTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The types of data we can store. Used in some lookup tables.
    //                  
    // ------------------------------------------------------------------------
    enum class EDataTypes
    {
        Cat
        , Collect
        , Image
        , Item
        , TitleSet
        , Count
        , Min = Cat
        , Max = TitleSet
    };
    CQCMEDIAEXPORT EDataTypes eXlatEDataTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEDataTypes(const EDataTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EDataTypes eVal);

    
    // ------------------------------------------------------------------------
    //  A status enum that is used a lot throughout the repo drivers, to
    //  indicate current state of the driver.
    //                  
    // ------------------------------------------------------------------------
    enum class ELoadStatus
    {
        Init
        , Loading
        , Ready
        , Failed
        , Count
        , Min = Init
        , Max = Failed
    };
    CQCMEDIAEXPORT ELoadStatus eXlatELoadStatus(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatELoadStatus(const ELoadStatus eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ELoadStatus eVal);

    
    // ------------------------------------------------------------------------
    //  This enum is used to indicate how to interpret the location info for a
    //  media collection or item.
    //  
    //  FileCol   - It's file path based, at the collection level, not per track
    //  FileItem  - It's file path based, on a per-item level
    //  Changer   - It's changer based, so at the collection level in the form "changer.slot"
    //                  
    // ------------------------------------------------------------------------
    enum class ELocTypes
    {
        FileCol
        , FileItem
        , Changer
        , Count
        , Min = FileCol
        , Max = Changer
    };
    CQCMEDIAEXPORT ELocTypes eXlatELocTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatELocTypes(const ELocTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT const TString& strAltXlatELocTypes(const ELocTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT ELocTypes eAltXlatELocTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ELocTypes eVal);

    
    // ------------------------------------------------------------------------
    //  This is used by the media player engines to report media end/error states. This
    //  has to be separate from the media states it reports (via EMediaStates below) because
    //  many players will report other states after an error or end of media report, so
    //  it would get overwritten before the client code sees the transition, and that would
    //  cause a failure to move to the next item in the playlist.
    //                  
    // ------------------------------------------------------------------------
    enum class EEndStates
    {
        Running
        , Ended
        , Failed
        , Count
        , Min = Running
        , Max = Failed
    };
    CQCMEDIAEXPORT EEndStates eXlatEEndStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEEndStates(const EEndStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EEndStates eVal);

    
    // ------------------------------------------------------------------------
    //  These are the standard states that a media renderer driver reports in the standard
    //  media state field. These happen to be those defined by the WMP engine, but these are
    //  sufficient for general use. Some drivers won't report them all and that's fine. As
    //  long as they report stopped, paused, playing and end of media that is fine.
    //  If they have other states beyond these, they can report them as undefined.
    //  
    //  Media end and error states are reported separately, using the EMediaEnds enum.
    //                  
    // ------------------------------------------------------------------------
    enum class EMediaStates
    {
        Undefined
        , Buffering
        , Loading
        , Playing
        , Paused
        , Stopped
        , Count
        , Min = Undefined
        , Max = Stopped
    };
    CQCMEDIAEXPORT EMediaStates eXlatEMediaStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEMediaStates(const EMediaStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EMediaStates eVal);

    
    // ------------------------------------------------------------------------
    //  The available media metadata related image fields. This is primairly for the
    //  Media Repo Image widget, which displays an image associated with one of
    //  the attributes of a media title.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out
    //          to disk in saved interfaces.
    //                  
    // ------------------------------------------------------------------------
    enum class EMImgAttrs
    {
        CoverArtLrg
        , CoverArtSml
        , RatingLg
        , RatingSm
        , RatingLgWh
        , RatingSmWh
        , PosterArt
        , Count
        , Min = CoverArtLrg
        , Max = PosterArt
    };
    CQCMEDIAEXPORT EMImgAttrs eXlatEMImgAttrs(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEMImgAttrs(const EMImgAttrs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TVoid FormatEMImgAttrs
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EMImgAttrs eVal);

    
    // ------------------------------------------------------------------------
    //  The available media metadata related text fields. This is primairly for the
    //  Media Repo Text widget, which displays a text value associated with one of
    //  the attributes of a media title.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out
    //          to disk in saved interfaces.
    //                  
    // ------------------------------------------------------------------------
    enum class EMTextAttrs
    {
        AspectRatio
        , Cast
        , Description
        , Label
        , Rating
        , RunTime
        , Title
        , Year
        , Artist
        , LeadActor
        , MediaFmt
        , RawRunTime
        , BitDepth
        , BitRate
        , Channels
        , DateAdded
        , SampleRate
        , SeqNum
        , UserRating
        , Name
        , Count
        , Min = AspectRatio
        , Max = Name
    };
    CQCMEDIAEXPORT EMTextAttrs eXlatEMTextAttrs(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEMTextAttrs(const EMTextAttrs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TVoid FormatEMTextAttrs
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EMTextAttrs eVal);

    
    // ------------------------------------------------------------------------
    //  Indicates the particular media type. This enumeration contains all of the
    //  types of media our architecture can support. Note that you can shift one left
    //  by the enum value here and get the correspnding bit in the EMTFlags enum,
    //  and this relationship must be maintained!
    //  
    //  The text needs to be inline since we use it in action command parameters.
    //                  
    // ------------------------------------------------------------------------
    enum class EMediaTypes
    {
        Movie
        , Music
        , Pic
        , Count
        , Min = Movie
        , Max = Pic
    };
    CQCMEDIAEXPORT EMediaTypes eXlatEMediaTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEMediaTypes(const EMediaTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TVoid FormatEMediaTypes
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
        );
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EMediaTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in places where we need to track the various types of media that are supported,
    //  not a single type. So it's a bitmapped enum. We have some combo values here as
    //  well.
    //                  
    // ------------------------------------------------------------------------
    enum class EMTFlags : tCIDLib::TCard4
    {
        Movie = 0x01
        , Music = 0x02
        , Pic = 0x04
        , MultiMedia = 0x03
        , Count = 4
        , None = 0
        , AllBits = 0x7
    };
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EMTFlags eVal);

    
    // ------------------------------------------------------------------------
    //  These provide the text (and internal values) for the playlist mode used by
    //  media renderer drivers. This guy is persisted so add new ones to the end.
    //                  
    // ------------------------------------------------------------------------
    enum class EPLModes
    {
        Normal
        , Jukebox
        , Shuffle
        , RandomCat
        , Count
        , Min = Normal
        , Max = RandomCat
    };
    CQCMEDIAEXPORT EPLModes eXlatEPLModes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEPLModes(const EPLModes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EPLModes eVal);

    
    // ------------------------------------------------------------------------
    //  This is returned from the playlist manager class when you ask it to do various things
    //  that would affect the play list. This tells the caller how to react.
    //                  
    // ------------------------------------------------------------------------
    enum class EPLMgrActs
    {
        Rejected
        , NoAction
        , NewItem
        , NewSelection
        , Stop
        , Count
        , Min = Rejected
        , Max = Stop
    };
    CQCMEDIAEXPORT EPLMgrActs eXlatEPLMgrActs(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatEPLMgrActs(const EPLMgrActs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EPLMgrActs eVal);

    
    // ------------------------------------------------------------------------
    //  This is returned from the playlist manager class when you ask it to select
    //  a new item. It'll tell the caller if a new selection was made, and if the play
    //  list changed due to the selection.
    //                  
    // ------------------------------------------------------------------------
    enum class EPLMgrSelRes
    {
        Empty
        , NewItem
        , NewAndChanged
        , Count
        , Min = Empty
        , Max = NewAndChanged
    };
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const EPLMgrSelRes eVal);

    
    // ------------------------------------------------------------------------
    //  The facility class provides a number of helpers to get art data from
    //  repo drivers. Generally these days it's gotten from the local cache,
    //  but sometimes it's still downloaded, and one of the times is to fill
    //  in that local cache of course.
    //                  
    // ------------------------------------------------------------------------
    enum class ERArtTypes
    {
        SmlCover
        , LrgCover
        , Poster
        , Count
        , Min = SmlCover
        , Max = Poster
    };
    CQCMEDIAEXPORT ERArtTypes eXlatERArtTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatERArtTypes(const ERArtTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ERArtTypes eVal);

    
    // ------------------------------------------------------------------------
    //  An enum for the standard renderer driver fields. Order isn't important.
    //  Primarily we have this because we have to support both V1 and V2
    //  naming conventions, and this lets us provide methods in our facility
    //  class that will return the names in either mode, given the enum for
    //  a particular field.
    //  
    //  Note that the text here MUST remain inline, else our facility class ctor
    //  will go into a circular freakout and overflow the stack!
    //  
    //  The order isn't important, these are runtime only
    //                  
    // ------------------------------------------------------------------------
    enum class ERendFlds
    {
        ActiveRepo
        , ClearPL
        , CurAspect
        , CurCast
        , CurColArtist
        , CurColCookie
        , CurColName
        , CurDescr
        , CurItName
        , CurItArtist
        , CurItCookie
        , CurItTime
        , CurItTotal
        , CurLabel
        , CurLeadActor
        , CurRating
        , CurTiName
        , CurTiCookie
        , CurYear
        , DelPLItem
        , EnqMedia
        , PBPercent
        , PlayMedia
        , PLItemCnt
        , PLItemKey
        , PLIndex
        , PLMode
        , PLSerialNum
        , SelPLItem
        , SetRandomCat
        , SetRepo
        , ZoneNum
        , Power
        , PowerStatus
        , AdjustVolume
        , Mute
        , Volume
        , MediaState
        , Transport
        , Count
        , Min = ActiveRepo
        , Max = Transport
    };
    CQCMEDIAEXPORT ERendFlds eXlatERendFlds(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatERendFlds(const ERendFlds eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT const TString& strAltXlatERendFlds(const ERendFlds eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT ERendFlds eAltXlatERendFlds(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ERendFlds eVal);

    
    // ------------------------------------------------------------------------
    //  Used in queries to repository drivers, when asking for the available
    //  titles in a given genre. Indicates the order the caller wants the returned
    //  list of title ids to be sorted. The text needs to be inline since we
    //  use it in action command parameters.
    //                  
    // ------------------------------------------------------------------------
    enum class ESortOrders
    {
        Artist
        , BitDepth
        , BitRate
        , Channels
        , DateAdded
        , DateAddedDesc
        , SampleRate
        , SeqNum
        , SeqNumDesc
        , Title
        , UserRating
        , UserRatingDesc
        , Year
        , YearDesc
        , Count
        , Min = Artist
        , Max = YearDesc
    };
    CQCMEDIAEXPORT ESortOrders eXlatESortOrders(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatESortOrders(const ESortOrders eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TVoid FormatESortOrders
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ESortOrders eVal);

    
    // ------------------------------------------------------------------------
    //  The enumerated field values for the stnadard media transport device
    //  class' transport field.
    //                  
    // ------------------------------------------------------------------------
    enum class ETransCmds
    {
        Pause
        , Play
        , Stop
        , Next
        , Previous
        , FF
        , Rewind
        , Count
        , Min = Pause
        , Max = Rewind
    };
    CQCMEDIAEXPORT ETransCmds eXlatETransCmds(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCMEDIAEXPORT const TString& strXlatETransCmds(const ETransCmds eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCMEDIAEXPORT tCIDLib::TBoolean bIsValidEnum(const ETransCmds eVal);

}

#pragma CIDLIB_POPPACK


CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ECompTypes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ECompTypes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ECompTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ECompTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::ECompTypes operator++(tCQCMedia::ECompTypes& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EDataTypes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EDataTypes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EDataTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EDataTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ELoadStatus eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ELoadStatus& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ELoadStatus* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ELoadStatus* const aeList, const tCIDLib::TCard4 c4Count);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ELocTypes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ELocTypes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ELocTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ELocTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EEndStates eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EEndStates& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EEndStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EEndStates* const aeList, const tCIDLib::TCard4 c4Count);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EMediaStates eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EMediaStates& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EMediaStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EMediaStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::EMediaStates operator++(tCQCMedia::EMediaStates& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EMImgAttrs eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EMImgAttrs& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EMImgAttrs* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EMImgAttrs* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::EMImgAttrs operator++(tCQCMedia::EMImgAttrs& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EMTextAttrs eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EMTextAttrs& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EMTextAttrs* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EMTextAttrs* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::EMTextAttrs operator++(tCQCMedia::EMTextAttrs& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EMediaTypes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EMediaTypes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EMediaTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EMediaTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::EMediaTypes operator++(tCQCMedia::EMediaTypes& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EMTFlags eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EMTFlags& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EMTFlags* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EMTFlags* const aeList, const tCIDLib::TCard4 c4Count);
constexpr tCQCMedia::EMTFlags operator|(const tCQCMedia::EMTFlags eLHS, const tCQCMedia::EMTFlags eRHS)
{    
    return tCQCMedia::EMTFlags(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCMedia::EMTFlags& operator|=(tCQCMedia::EMTFlags& eLHS, const tCQCMedia::EMTFlags eRHS)
{    
    eLHS = tCQCMedia::EMTFlags(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
constexpr tCQCMedia::EMTFlags operator&(const tCQCMedia::EMTFlags eLHS, const tCQCMedia::EMTFlags eRHS)
{    
    return tCQCMedia::EMTFlags(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCMedia::EMTFlags& operator&=(tCQCMedia::EMTFlags& eLHS, const tCQCMedia::EMTFlags eRHS)
{    
    eLHS = tCQCMedia::EMTFlags(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::EPLModes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::EPLModes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::EPLModes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::EPLModes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::EPLModes operator++(tCQCMedia::EPLModes& eVal, int);



CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ERArtTypes eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ERArtTypes& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ERArtTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ERArtTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCMEDIAEXPORT tCQCMedia::ERendFlds operator++(tCQCMedia::ERendFlds& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ESortOrders eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ESortOrders& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ESortOrders* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ESortOrders* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::ESortOrders operator++(tCQCMedia::ESortOrders& eVal, int);

CQCMEDIAEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCMedia::ETransCmds eToStream);
CQCMEDIAEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCMedia::ETransCmds& eToFill);
CQCMEDIAEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCMedia::ETransCmds* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCMedia::ETransCmds* const aeList, const tCIDLib::TCard4 c4Count);
CQCMEDIAEXPORT tCQCMedia::ETransCmds operator++(tCQCMedia::ETransCmds& eVal, int);

