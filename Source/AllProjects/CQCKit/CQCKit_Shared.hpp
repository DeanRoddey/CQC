// ----------------------------------------------------------------------------
//  FILE: CQCKit_Shared.hpp
//  DATE: Tue, Sep 01 20:12:16 2020 -0400
//
//  This file was generated by the Charmed Quark CIDIDL compiler. Do not make
//  changes by hand, because they will be lost if the file is regenerated.
// ----------------------------------------------------------------------------
#pragma once

#pragma CIDLIB_PACK(CIDLIBPACK)

// ----------------------------------------------------------------------------
// Constants namespace
// ----------------------------------------------------------------------------
namespace kCQCKit
{
    
    // ------------------------------------------------------------------------
    //  The maximum number of command parameters a standard CQC command can
    //  accept.
    //                  
    // ------------------------------------------------------------------------
    constexpr tCIDLib::TCard4 c4MaxCmdParms = 4;
    
    // ------------------------------------------------------------------------
    //  The topic path for incoming event triggers. If incoming trigger
    //  processing is enabled, a topic with this path is created. Anyone who
    //  wants to react to incoming triggers can create a subscription for
    //  this topic path.
    //  
    //  These may come in fairly rapidly, so the subscribers should be good
    //  about processing their subscription's incoming message queue.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strPubTopic_EvTriggers;
    
    // ------------------------------------------------------------------------
    //  These are the attribute ids for the small set of attributes that
    //  we have to deal with at this level. Mostly they are in the CQCIntfEng
    //  facility.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strAttr_Actions;
    CQCKITEXPORT const extern TString strAttr_Expr_CompVal;
    CQCKITEXPORT const extern TString strAttr_Expr_Descr;
    CQCKITEXPORT const extern TString strAttr_Expr_Negated;
    CQCKITEXPORT const extern TString strAttr_Expr_Statement;
    CQCKITEXPORT const extern TString strAttr_Expr_Type;
    
    // ------------------------------------------------------------------------
    //  To aid the RIVA client, we store info in the bitmaps that we load into
    //  our image cache, which the remoted graphics device can pull out when a
    //  bitmap draw is done, and send to the other side to tell him what image
    //  to draw. These prefixes are put before the image path, so that the remote
    //  viewer client will know what type of image it is and therefore how to
    //  get it.
    //  
    //  These are defined here because the interface engine needs to see them as
    //  well.
    //  
    //  Media poster art was added in 4.4.912, to support the display
    //  of poster art.
    //  
    //  NSRendArt was added in 4.4.934 to support media players that don't use the
    //  standard PLItemKey field format. In that case, there's nothing we can give to
    //  the RIVA clients to represent that image. So this will just always represent
    //  the current art of the driver. When the RIVA server gets a request of this type
    //  it will just go to the renderer to get the art and return it. The format of
    //  of the key is "NSRendArt:moniker uid:, so the moniker plus whatever unique
    //  id it put into the PLItemKey field, which must be different for every new
    //  image, so it should force the RIVA client to come get it again, even if
    //  the serial number is always just 1.
    //  
    //  'On the fly' images were added 5.1.4 in the move to the new WebRIVA system,
    //  which can now deal with the types of images the IV engine builds on the
    //  fly, such as color palettes. A unique id will just be generated for each
    //  such image, and appended to the prefix. The serial number will always just
    //  be 1. That will be enough for the client to know which image is being
    //  referred to.
    //  
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strWRIVA_RepoPref;
    CQCKITEXPORT const extern TString strWRIVA_ArtPref;
    CQCKITEXPORT const extern TString strWRIVA_WebPref;
    CQCKITEXPORT const extern TString strWRIVA_DrvPref;
    CQCKITEXPORT const extern TString strWRIVA_PArtPref;
    CQCKITEXPORT const extern TString strWRIVA_NSRendArtPref;
    CQCKITEXPORT const extern TString strWRIVA_IVOTFPref;
    
    // ------------------------------------------------------------------------
    //  The prefixes of the common runtime values.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strRTVPref_Std;
    CQCKITEXPORT const extern TString strRTVPref_EvFld;
    
    // ------------------------------------------------------------------------
    //  Prefixes for global and local action variables and some special
    //  action variable names and starting parts.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strActVarPref_GVar;
    CQCKITEXPORT const extern TString strActVarPref_LVar;
    CQCKITEXPORT const extern TString strActVarPref_Parm;
    
    // ------------------------------------------------------------------------
    //  The command target prefixes for the well known types of command targets
    //  in the CQC system.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strTarPref_Std;
    CQCKITEXPORT const extern TString strTarPref_Widgets;
    CQCKITEXPORT const extern TString strTarPref_Interface;
    
    // ------------------------------------------------------------------------
    //  Unique ids for the standard command targets, which are always available to
    //  commands, for macros, field writes, system calls.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strCTarId_MacroEngine;
    CQCKITEXPORT const extern TString strCTarId_Fields;
    CQCKITEXPORT const extern TString strCTarId_System;
    CQCKITEXPORT const extern TString strCTarId_GVars;
    CQCKITEXPORT const extern TString strCTarId_LVars;
    CQCKITEXPORT const extern TString strCTarId_TrigEvent;
    CQCKITEXPORT const extern TString strCTarId_EventSrv;
    
    // ------------------------------------------------------------------------
    //  Unique ids for the CQC commands that we understand at this level. These are the
    //  commands that are basically always available, no matter what environment that
    //  commands are being invoked in.
    //  
    //  We also define some special ones that are used to mark conditional commands,
    //  which are interpreted directly by the command processing engine. Command config
    //  objects marked with these contain one or two nested chunks of commands, that
    //  represent the blocks of commands to do for the If or Else part of the
    //  conditional.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strCmdId_Pause;
    CQCKITEXPORT const extern TString strCmdId_Append;
    CQCKITEXPORT const extern TString strCmdId_Clear;
    CQCKITEXPORT const extern TString strCmdId_Delete;
    CQCKITEXPORT const extern TString strCmdId_DeleteLast;
    CQCKITEXPORT const extern TString strCmdId_Enable;
    CQCKITEXPORT const extern TString strCmdId_ExecApp;
    CQCKITEXPORT const extern TString strCmdId_Exit;
    CQCKITEXPORT const extern TString strCmdId_FieldWrite;
    CQCKITEXPORT const extern TString strCmdId_HideShow;
    CQCKITEXPORT const extern TString strCmdId_RunMacro;
    CQCKITEXPORT const extern TString strCmdId_SayText;
    CQCKITEXPORT const extern TString strCmdId_SendValue;
    CQCKITEXPORT const extern TString strCmdId_ScrollList;
    CQCKITEXPORT const extern TString strCmdId_ScrollToChar;
    CQCKITEXPORT const extern TString strCmdId_SetColor;
    CQCKITEXPORT const extern TString strCmdId_SetImage;
    CQCKITEXPORT const extern TString strCmdId_SetNamedImage;
    CQCKITEXPORT const extern TString strCmdId_SetPattern;
    CQCKITEXPORT const extern TString strCmdId_SetText;
    CQCKITEXPORT const extern TString strCmdId_ShowText;
    CQCKITEXPORT const extern TString strCmdId_WaitDriverReady;
    CQCKITEXPORT const extern TString strCmdId_WaitFieldVal;
    CQCKITEXPORT const extern TString strCmdId_WebNavOp;
    CQCKITEXPORT const extern TString strCmdId_WebNavURL;
    CQCKITEXPORT const extern TString strCmdId_SetSysVolume;
    CQCKITEXPORT const extern TString strCmdId_MuteSystem;
    CQCKITEXPORT const extern TString strCmdId_Add;
    CQCKITEXPORT const extern TString strCmdId_AND;
    CQCKITEXPORT const extern TString strCmdId_Back;
    CQCKITEXPORT const extern TString strCmdId_BitIsOn;
    CQCKITEXPORT const extern TString strCmdId_CapAt;
    CQCKITEXPORT const extern TString strCmdId_DelSubStr;
    CQCKITEXPORT const extern TString strCmdId_DelVariable;
    CQCKITEXPORT const extern TString strCmdId_Divide;
    CQCKITEXPORT const extern TString strCmdId_Exists;
    CQCKITEXPORT const extern TString strCmdId_Find;
    CQCKITEXPORT const extern TString strCmdId_FmtNumAsSpoken;
    CQCKITEXPORT const extern TString strCmdId_GetLength;
    CQCKITEXPORT const extern TString strCmdId_GetNthToken;
    CQCKITEXPORT const extern TString strCmdId_GetSubStr;
    CQCKITEXPORT const extern TString strCmdId_GetText;
    CQCKITEXPORT const extern TString strCmdId_Insert;
    CQCKITEXPORT const extern TString strCmdId_Multiply;
    CQCKITEXPORT const extern TString strCmdId_OR;
    CQCKITEXPORT const extern TString strCmdId_Replace;
    CQCKITEXPORT const extern TString strCmdId_ReplaceToken;
    CQCKITEXPORT const extern TString strCmdId_SetVariable;
    CQCKITEXPORT const extern TString strCmdId_SpeakChars;
    CQCKITEXPORT const extern TString strCmdId_SplitAt;
    CQCKITEXPORT const extern TString strCmdId_Subtract;
    CQCKITEXPORT const extern TString strCmdId_ToLower;
    CQCKITEXPORT const extern TString strCmdId_ToUpper;
    CQCKITEXPORT const extern TString strCmdId_UpLevel;
    CQCKITEXPORT const extern TString strCmdId_Equals;
    CQCKITEXPORT const extern TString strCmdId_GreaterTh;
    CQCKITEXPORT const extern TString strCmdId_GreaterThEq;
    CQCKITEXPORT const extern TString strCmdId_IsInNumericRange;
    CQCKITEXPORT const extern TString strCmdId_IsInTimeRange;
    CQCKITEXPORT const extern TString strCmdId_LessTh;
    CQCKITEXPORT const extern TString strCmdId_LessThEq;
    CQCKITEXPORT const extern TString strCmdId_StartsWith;
    CQCKITEXPORT const extern TString strCmdId_DriverReady;
    CQCKITEXPORT const extern TString strCmdId_FieldRead;
    CQCKITEXPORT const extern TString strCmdId_FieldRead2;
    CQCKITEXPORT const extern TString strCmdId_FieldWrite2;
    CQCKITEXPORT const extern TString strCmdId_GetTimerVal;
    CQCKITEXPORT const extern TString strCmdId_IsNightTime;
    CQCKITEXPORT const extern TString strCmdId_PlayWAV;
    CQCKITEXPORT const extern TString strCmdId_SendWOL;
    CQCKITEXPORT const extern TString strCmdId_StartRemApp;
    CQCKITEXPORT const extern TString strCmdId_Stop;
    CQCKITEXPORT const extern TString strCmdId_ResetTimer;
    CQCKITEXPORT const extern TString strCmdId_WaitTimer;
    CQCKITEXPORT const extern TString strCmdId_IsFldChangeEv;
    CQCKITEXPORT const extern TString strCmdId_IsFldChangeEvFor;
    CQCKITEXPORT const extern TString strCmdId_IsUserActionEv;
    CQCKITEXPORT const extern TString strCmdId_IsUserActionEvFor;
    CQCKITEXPORT const extern TString strCmdId_GetEventFld;
    CQCKITEXPORT const extern TString strCmdId_GenRandNum;
    CQCKITEXPORT const extern TString strCmdId_IsUserActionEvFrom;
    CQCKITEXPORT const extern TString strCmdId_GetUserActionVals;
    CQCKITEXPORT const extern TString strCmdId_ClearDrvStats;
    CQCKITEXPORT const extern TString strCmdId_LogMsg;
    CQCKITEXPORT const extern TString strCmdId_EMail;
    CQCKITEXPORT const extern TString strCmdId_Strip;
    CQCKITEXPORT const extern TString strCmdId_IsThisUserActionEv;
    CQCKITEXPORT const extern TString strCmdId_FormatTimeVal;
    CQCKITEXPORT const extern TString strCmdId_QueryDrvText;
    CQCKITEXPORT const extern TString strCmdId_SendDrvCmd;
    CQCKITEXPORT const extern TString strCmdId_GetShowText;
    CQCKITEXPORT const extern TString strCmdId_SetButtonText;
    CQCKITEXPORT const extern TString strCmdId_PauseSchEvent;
    CQCKITEXPORT const extern TString strCmdId_GetSchEvInfo;
    CQCKITEXPORT const extern TString strCmdId_SetSchEvTime;
    CQCKITEXPORT const extern TString strCmdId_GetSunEvInfo;
    CQCKITEXPORT const extern TString strCmdId_SetSunEvOffset;
    CQCKITEXPORT const extern TString strCmdId_GetPerEvInfo;
    CQCKITEXPORT const extern TString strCmdId_SetPerEvTime;
    CQCKITEXPORT const extern TString strCmdId_GetDateParts;
    CQCKITEXPORT const extern TString strCmdId_GetTimeParts;
    CQCKITEXPORT const extern TString strCmdId_AddQListValue;
    CQCKITEXPORT const extern TString strCmdId_GetState;
    CQCKITEXPORT const extern TString strCmdId_SetState;
    CQCKITEXPORT const extern TString strCmdId_SetValue;
    CQCKITEXPORT const extern TString strCmdId_SetPeriod;
    CQCKITEXPORT const extern TString strCmdId_CreateVariable;
    CQCKITEXPORT const extern TString strCmdId_SetVarFmt;
    CQCKITEXPORT const extern TString strCmdId_LinkToField;
    CQCKITEXPORT const extern TString strCmdId_LinkToVar;
    CQCKITEXPORT const extern TString strCmdId_TimedFldChange;
    CQCKITEXPORT const extern TString strCmdId_CancelTimedFldChange;
    CQCKITEXPORT const extern TString strCmdId_HasQueuedFldChange;
    CQCKITEXPORT const extern TString strCmdId_HTMLEMail;
    CQCKITEXPORT const extern TString strCmdId_GetNumericRange;
    CQCKITEXPORT const extern TString strCmdId_InvokeFile;
    CQCKITEXPORT const extern TString strCmdId_EnableSchEvent;
    CQCKITEXPORT const extern TString strCmdId_WaitTTSDone;
    CQCKITEXPORT const extern TString strCmdId_SayTextAndWait;
    CQCKITEXPORT const extern TString strCmdId_ScrollToIndex;
    CQCKITEXPORT const extern TString strCmdId_GetCount;
    CQCKITEXPORT const extern TString strCmdId_GetIndex;
    CQCKITEXPORT const extern TString strCmdId_CvtToElapsed;
    CQCKITEXPORT const extern TString strCmdId_TrySetVariable;
    CQCKITEXPORT const extern TString strCmdId_SetNowPlus;
    CQCKITEXPORT const extern TString strCmdId_ElapsedSince;
    CQCKITEXPORT const extern TString strCmdId_GetStrListCnt;
    CQCKITEXPORT const extern TString strCmdId_GetJulianDate;
    CQCKITEXPORT const extern TString strCmdId_TestAndSet;
    CQCKITEXPORT const extern TString strCmdId_ReplaceSubStr;
    CQCKITEXPORT const extern TString strCmdId_DoGlobalAct;
    CQCKITEXPORT const extern TString strCmdId_Reset;
    CQCKITEXPORT const extern TString strCmdId_AdjustEnumValue;
    CQCKITEXPORT const extern TString strCmdId_SetValueFrom;
    CQCKITEXPORT const extern TString strCmdId_GetEnumOrdinal;
    CQCKITEXPORT const extern TString strCmdId_QueryDrvBoolVal;
    CQCKITEXPORT const extern TString strCmdId_SayIVText;
    CQCKITEXPORT const extern TString strCmdId_PlayIVWAV;
    CQCKITEXPORT const extern TString strCmdId_SetIVTemplate;
    CQCKITEXPORT const extern TString strCmdId_SafeCreateVariable;
    CQCKITEXPORT const extern TString strCmdId_MarkByIndex;
    CQCKITEXPORT const extern TString strCmdId_GetMarkedIndex;
    CQCKITEXPORT const extern TString strCmdId_SafeWaitFieldVal;
    CQCKITEXPORT const extern TString strCmdId_IsCharAt;
    CQCKITEXPORT const extern TString strCmdId_PutCharAt;
    CQCKITEXPORT const extern TString strCmdId_GetPresenceInfo;
    CQCKITEXPORT const extern TString strCmdId_FindDrivers;
    CQCKITEXPORT const extern TString strCmdId_SetMoniker;
    CQCKITEXPORT const extern TString strCmdId_SetTimeVar;
    CQCKITEXPORT const extern TString strCmdId_FindByText;
    CQCKITEXPORT const extern TString strCmdId_GetLockStatusInfo;
    CQCKITEXPORT const extern TString strCmdId_EMailURLImg;
    CQCKITEXPORT const extern TString strCmdId_SaveURLImg;
    CQCKITEXPORT const extern TString strCmdId_GetZoneAlarmInfo;
    CQCKITEXPORT const extern TString strCmdId_IsFldSrc;
    CQCKITEXPORT const extern TString strCmdId_IsDevSrc;
    CQCKITEXPORT const extern TString strCmdId_GetFldChangeInfo;
    CQCKITEXPORT const extern TString strCmdId_GetMotionInfo;
    CQCKITEXPORT const extern TString strCmdId_GetLoadChangeInfo;
    CQCKITEXPORT const extern TString strCmdId_Negate;
    CQCKITEXPORT const extern TString strCmdId_IsInList;
    CQCKITEXPORT const extern TString strCmdId_Scroll;
    CQCKITEXPORT const extern TString strCmdId_CalcGeoDistance;
    CQCKITEXPORT const extern TString strCmdId_GetColor;
    CQCKITEXPORT const extern TString strCmdId_SetClrComps;
    CQCKITEXPORT const extern TString strCmdId_GetNthEnumVal;
    CQCKITEXPORT const extern TString strCmdId_CreateVarFromField;
    CQCKITEXPORT const extern TString strCmdId_QueryDrvCardVal;
    CQCKITEXPORT const extern TString strCmdId_QueryDrvIntVal;
    CQCKITEXPORT const extern TString strCmdId_SetIVBlanker;
    CQCKITEXPORT const extern TString strCmdId_PauseEvMon;
    CQCKITEXPORT const extern TString strCmdId_HTTPGet;
    CQCKITEXPORT const extern TString strCmdId_IsWeekDay;
    CQCKITEXPORT const extern TString strCmdId_GetDayOfWeek;
    CQCKITEXPORT const extern TString strCmdId_GetSemFields;
    CQCKITEXPORT const extern TString strCmdId_PauseTrgEvent;
    CQCKITEXPORT const extern TString strCmdId_EvalExpr;
    CQCKITEXPORT const extern TString strCmdId_SetURL;
    CQCKITEXPORT const extern TString strCmdId_SetMute;
    CQCKITEXPORT const extern TString strCmdId_SetVolume;
    CQCKITEXPORT const extern TString strCmdId_SetWebURL;
    CQCKITEXPORT const extern TString strCmdId_GetUserData;
    CQCKITEXPORT const extern TString strCmdId_GetValue;
    CQCKITEXPORT const extern TString strCmdId_GetCurTimeStamp;
    CQCKITEXPORT const extern TString strCmdId_FindFields;
    
    // ------------------------------------------------------------------------
    //  These are unique ids for various command events that are very fundamental and
    //  likely to be used widely.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strEvId_OnRepeat;
    CQCKITEXPORT const extern TString strEvId_OnPress;
    CQCKITEXPORT const extern TString strEvId_OnRelease;
    CQCKITEXPORT const extern TString strEvId_OnDrag;
    CQCKITEXPORT const extern TString strEvId_OnSelect;
    CQCKITEXPORT const extern TString strEvId_OnLoad;
    CQCKITEXPORT const extern TString strEvId_OnScheduledTime;
    CQCKITEXPORT const extern TString strEvId_OnClick;
    CQCKITEXPORT const extern TString strEvId_OnFalseClick;
    CQCKITEXPORT const extern TString strEvId_OnTrueClick;
    CQCKITEXPORT const extern TString strEvId_OnSet;
    CQCKITEXPORT const extern TString strEvId_OnTrigger;
    CQCKITEXPORT const extern TString strEvId_OnError;
    CQCKITEXPORT const extern TString strEvId_OnSuccess;
    CQCKITEXPORT const extern TString strEvId_OnScroll;
    CQCKITEXPORT const extern TString strEvId_OnPreload;
    CQCKITEXPORT const extern TString strEvId_OnTimeout;
    CQCKITEXPORT const extern TString strEvId_OnExit;
    CQCKITEXPORT const extern TString strEvId_OnExtClick;
    CQCKITEXPORT const extern TString strEvId_OnFlick;
    
    // ------------------------------------------------------------------------
    //  These are the two main branches of all of the repositories that we
    //  provide. Everything is either user stuff or system stuff. We have two
    //  versions of each, one of which has the trailing slahs the other doesn't.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strRepoScope_User;
    CQCKITEXPORT const extern TString strRepoScope_UserTS;
    CQCKITEXPORT const extern TString strRepoScope_System;
    CQCKITEXPORT const extern TString strRepoScope_SystemTS;
    
    // ------------------------------------------------------------------------
    //  These are ids for the most common runtime values. Most of these are provided
    //  by the base runtime value class and therefore are always available. Some are
    //  just common ones that are used often enough that we want to put them here where
    //  everyone can see them. The _EnvXX ones just resolve to the value of environment
    //  variables CQCRTV_XX.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strRTVId_Millis;
    CQCKITEXPORT const extern TString strRTVId_MMDDYYYY;
    CQCKITEXPORT const extern TString strRTVId_DDMMYYYY;
    CQCKITEXPORT const extern TString strRTVId_YYYY;
    CQCKITEXPORT const extern TString strRTVId_HHMM;
    CQCKITEXPORT const extern TString strRTVId_HHMMSS;
    CQCKITEXPORT const extern TString strRTVId_HostName;
    CQCKITEXPORT const extern TString strRTVId_WeekDay;
    CQCKITEXPORT const extern TString strRTVId_CurValue;
    CQCKITEXPORT const extern TString strRTVId_Env01;
    CQCKITEXPORT const extern TString strRTVId_Env02;
    CQCKITEXPORT const extern TString strRTVId_Env03;
    CQCKITEXPORT const extern TString strRTVId_Env04;
    CQCKITEXPORT const extern TString strRTVId_Env05;
    CQCKITEXPORT const extern TString strRTVId_Env06;
    CQCKITEXPORT const extern TString strRTVId_Env07;
    CQCKITEXPORT const extern TString strRTVId_Env08;
    CQCKITEXPORT const extern TString strRTVId_Env09;
    CQCKITEXPORT const extern TString strRTVId_ErrorMsg;
    CQCKITEXPORT const extern TString strRTVId_DayNumber;
    CQCKITEXPORT const extern TString strRTVId_Hour;
    CQCKITEXPORT const extern TString strRTVId_Minute;
    CQCKITEXPORT const extern TString strRTVId_Month;
    CQCKITEXPORT const extern TString strRTVId_MonthNumber;
    CQCKITEXPORT const extern TString strRTVId_CurUserName;
    CQCKITEXPORT const extern TString strRTVId_IPAddr;
    CQCKITEXPORT const extern TString strRTVId_CQCVersion;
    CQCKITEXPORT const extern TString strRTVId_FirstIndex;
    CQCKITEXPORT const extern TString strRTVId_SelectIndex;
    CQCKITEXPORT const extern TString strRTVId_CurDateTime;
    CQCKITEXPORT const extern TString strRTVId_TimeStamp;
    CQCKITEXPORT const extern TString strRTVId_TEvClass;
    CQCKITEXPORT const extern TString strRTVId_TEvSource;
    CQCKITEXPORT const extern TString strRTVId_TEvNewFldVal;
    CQCKITEXPORT const extern TString strRTVId_TEvSrcMoniker;
    CQCKITEXPORT const extern TString strRTVId_TEvSrcField;
    CQCKITEXPORT const extern TString strRTVId_CurUserRole;
    CQCKITEXPORT const extern TString strRTVId_MarkIndex;
    CQCKITEXPORT const extern TString strRTVId_SelTime;
    CQCKITEXPORT const extern TString strRTVId_MSHost;
    CQCKITEXPORT const extern TString strRTVId_CurText;
    
    // ------------------------------------------------------------------------
    //  This is used to mark the web server that is running on the master server,
    //  in its name server entry so that it can be found by other CQC hosts. It
    //  is used by the CQCKit facility's finder helper, and by the web server
    //  itself to mark itself when it registers with the name server.
    //                  
    // ------------------------------------------------------------------------
    CQCKITEXPORT const extern TString strMSWebSrv;
}

// ----------------------------------------------------------------------------
// Types namespace
// ----------------------------------------------------------------------------
namespace tCQCKit
{
    
    // ------------------------------------------------------------------------
    //  Command targets report the commands that they support. But in some
    //  situations, we don't want them to report all their commands. So we
    //  have a command context that get's passed to the query. Each target
    //  can selectively indicate command availability based on the context.
    //  
    //  Standard - No particular limitations. Load all available commands.
    //  
    //  IVEvent - For an action invoked in response to an event received
    //  in the interface viewer. This is a very restricted scenario.
    //  
    //  NoContChange - Used in the interface viewer, to suppress any commands
    //  that could reload the current container (template or overlay) so that
    //  a widget invoking the action cannot itself be destroyed. We only allow
    //  certain widget types to do this, so that we only have to deal with
    //  this special case issue in a limited set of situations.
    //  
    //  Preload - An extremely restricted scenario, for an action invoked on
    //  an IV template after loading but before initialization. Mostly to
    //  allow hide/show stuff and to change the field or variable that a
    //  widget is assigned to. We also have an exit event for templates
    //  that is used when popup closes, and we use this same context for
    //  that since the same sorts of limitations would apply. It's called
    //  before anything is cleaned up, mostly it's for destroying any
    //  global variables it used.
    //  
    //  OnError - Some action engines support an OnError that is invoked if
    //  an error occurs in another event. We have a special context for that
    //  in case anyone needs to stop certain things from being done in that
    //  special case.
    //  
    //  NOTE: As of 2.4.17 this is persisted, so add new ones to the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EActCmdCtx
    {
        Standard
        , IVEvent
        , NoContChange
        , Preload
        , OnError
        , Count
        , Min = Standard
        , Max = OnError
    };
    CQCKITEXPORT EActCmdCtx eXlatEActCmdCtx(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEActCmdCtx(const EActCmdCtx eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EActCmdCtx eVal);

    
    // ------------------------------------------------------------------------
    //  Used to mark the steps (opcodes) in an action, as to what kind of operation
    //  that step represents.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out to
    //          disk in many places
    //                  
    // ------------------------------------------------------------------------
    enum class EActOps
    {
        If
        , Else
        , Cmd
        , End
        , Comment
        , Count
        , Min = If
        , Max = Comment
    };
    CQCKITEXPORT EActOps eXlatEActOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEActOps(const EActOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EActOps eVal);

    
    // ------------------------------------------------------------------------
    //  The results returned from the standard token replacement method of
    //  the facility class.
    //                  
    // ------------------------------------------------------------------------
    enum class ECmdPrepRes
    {
        Unchanged
        , Failed
        , Changed
        , Count
        , Min = Unchanged
        , Max = Changed
    };
    CQCKITEXPORT const TString& strAltXlatECmdPrepRes(const ECmdPrepRes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT ECmdPrepRes eAltXlatECmdPrepRes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ECmdPrepRes eVal);

    
    // ------------------------------------------------------------------------
    //  Command targets return these values from the eDoCmd method, which tells the
    //  command engine dispatching the commands how to react, and the engine in turn
    //  returns these to indicate the ultimate result of the action. Anything
    //  Except or beyond is an error, so the order is important! These aren't persisted.
    //                  
    // ------------------------------------------------------------------------
    enum class ECmdRes
    {
        Ok
        , Stop
        , Exit
        , Except
        , UnknownExcept
        , Unknown
        , Count
        , Min = Ok
        , Max = Unknown
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ECmdRes eVal);

    
    // ------------------------------------------------------------------------
    //  The types of parameters that a command can take. This is used to provide
    //  guided entry of the parameters. In 5.1.4 we added a 'Number' type for
    //  things like math operations on variables, which need to be able to take
    //  any type of number. The target variable will determine the type, and they
    //  can use #C8 type suffixes as well.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out to
    //          disk in many places
    //                  
    // ------------------------------------------------------------------------
    enum class ECmdPTypes
    {
        None
        , Application
        , Area
        , Boolean
        , Driver
        , Enum
        , Field
        , ImgPath
        , Macro
        , Point
        , RegXText
        , Signed
        , Template
        , Text
        , Unsigned
        , Color
        , Path
        , File
        , EMailAcct
        , SchEvId
        , TarSubAction
        , VarName
        , GlobAction
        , QuotedList
        , TrayMonBinding
        , Host
        , IV
        , EvMonId
        , TrgEvId
        , Expression
        , Number
        , Count
        , Min = None
        , Max = Number
    };
    CQCKITEXPORT ECmdPTypes eXlatECmdPTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatECmdPTypes(const ECmdPTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ECmdPTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in the command target mixin, returned by the eValidate() method to
    //  indicate if the command config seems ok or not. The 'confirm' return means
    //  that the user should be warned about a problem but let them override it.
    //                  
    // ------------------------------------------------------------------------
    enum class ECmdValRes
    {
        Ok
        , Failed
        , Confirm
        , UnknownCmd
        , Count
        , Min = Ok
        , Max = UnknownCmd
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ECmdValRes eVal);

    
    // ------------------------------------------------------------------------
    //  Returned from the ePoll(), eConnect(), or field change methods, to indicate
    //   the result of the operation. The ValueRejected and beyond values are only
    //  valid from field change methods.
    //  
    //  They aren't stored, so order isn't important across releases.
    //                  
    // ------------------------------------------------------------------------
    enum class ECommResults
    {
        Success
        , LostConnection
        , LostCommRes
        , ValueRejected
        , Access
        , BadValue
        , Busy
        , CmdParms
        , CommError
        , DeviceResponse
        , Exception
        , FieldNotFound
        , Full
        , Internal
        , Limits
        , MissingInfo
        , NotReady
        , NotSupported
        , PowerState
        , ResNotAvail
        , ResNotFound
        , Unhandled
        , UnknownCmd
        , Count
        , Min = Success
        , Max = UnknownCmd
    };
    CQCKITEXPORT ECommResults eXlatECommResults(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatECommResults(const ECommResults eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatECommResults(const ECommResults eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT ECommResults eAltXlatECommResults(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ECommResults eVal);

    
    // ------------------------------------------------------------------------
    //  This enum provides a list of broad device categories, separate from the device
    //  classes below, which are more fractional type of indicators of specific types of
    //  functionality. These are used really for filtered selection by device type, where
    //  the device classes are used for indicating what functionality drivers support.
    //  
    //      NOTE:   Put new values at the END because these values are persisted
    //                  
    // ------------------------------------------------------------------------
    enum class EDevCats
    {
        Amplifier
        , AudioSwitcher
        , CDPlayer
        , ContactClosure
        , DVD
        , DVDScalerCombo
        , TV
        , FrontProjector
        , HVAC
        , IRBlaster
        , IRCombo
        , IRReceiver
        , JukeBox
        , LightingSystem
        , LD
        , Miscellaneous
        , MiniDisc
        , Motor
        , Plasma
        , PLC
        , PowerStrip
        , Processor
        , PVR
        , RearProjector
        , Receiver
        , Relay
        , Router
        , Security
        , SetTopBox
        , SmartController
        , SmartPanel
        , Speaker
        , Transducer
        , Tuner
        , VCR
        , VCRTVCombo
        , VideoProcessor
        , VideoScaler
        , VideoSwitcher
        , X10
        , Thermostat
        , MediaCombo
        , MediaRenderer
        , MediaRepository
        , PBX
        , IRLearner
        , MZAudio
        , ADIO
        , Speech
        , Scheduling
        , VideoConf
        , MediaPlayer
        , Appliance
        , Weather
        , PowerMon
        , Irrigation
        , Count
        , Min = Amplifier
        , Max = Irrigation
    };
    CQCKITEXPORT EDevCats eXlatEDevCats(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEDevCats(const EDevCats eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TVoid FormatEDevCats
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::BaseName
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDevCats eVal);

    
    // ------------------------------------------------------------------------
    //  The supported device categoryes (device classes now in the V2 architecture. This
    //  is a new thing only supported by V2 drivers. Unlike the device categories above,
    //  which are broad, high level function categories, these are very narrow and
    //  indicate what sets of functionality drivers support.
    //  
    //  When these are persisted, it's done using the basename so order isn't important.
    //  Since more will be added over time and we'd like to be able to keep them in order
    //  for convenience, this will be a nice thing, though more work in the streaming code
    //  of the driver config class.
    //  
    //  We use the AltText feature so we can also provide a mapping to/from the field
    //  name prefix for each class.
    //  
    //  Neither the name nor the alt text can have spaces in it.
    //                  
    // ------------------------------------------------------------------------
    enum class EDevClasses
    {
        None
        , Amplifier
        , Audio
        , AIO
        , AVProcessor
        , ClrLighting
        , ContactClosure
        , DeviceInfo
        , DIO
        , HVAC
        , Irrigation
        , IRBlaster
        , IRLearner
        , IRReceiver
        , Lighting
        , Lock
        , MediaPlayer
        , MediaRenderer
        , MediaRepository
        , MediaTransport
        , NowPlaying
        , MotionSensor
        , MZAudio
        , PBX
        , PoolCtrl
        , Power
        , Projector
        , PVR
        , Relay
        , ResMon
        , Router
        , SceneCtrl
        , Security
        , SetTopBox
        , Shades
        , Simulator
        , Stereo
        , Switcher
        , TempSensor
        , Thermostat
        , Tuner
        , TV
        , Weather
        , Count
        , Min = None
        , Max = Weather
    };
    CQCKITEXPORT EDevClasses eXlatEDevClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEDevClasses(const EDevClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEDevClasses(const EDevClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EDevClasses eAltXlatEDevClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strAltXlat2EDevClasses(const EDevClasses eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EDevClasses eAltXlat2EDevClasses(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDevClasses eVal);

    
    // ------------------------------------------------------------------------
    //  In the second generation driver arcthitecture, each driver must report a
    //  set of driver capabilities. These are set in the manifest file so that they
    //  don't require the driver to be loaded to figure them out. Old style drivers
    //  will just return the _None value. These are used as indices into a mask to
    //  store the flags.
    //                  
    // ------------------------------------------------------------------------
    enum class EDrvCaps
    {
        None
        , DevProbe
        , AutoLoc
        , Count
        , Min = None
        , Max = AutoLoc
    };
    CQCKITEXPORT EDrvCaps eXlatEDrvCaps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEDrvCaps(const EDrvCaps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDrvCaps eVal);

    
    // ------------------------------------------------------------------------
    //  As of 4.2.908 all calls to drivers that would cause a call out to a driver
    //  callback are queued up. The caller doesn't have to wait. Drivers can have a
    //  policy about whether they want clients to wait or not wait if the client
    //  doesn't have a particular intention on a given call. This is used to indicate
    //  whether to take the driver's policy, or to explicitly wait or not wait.
    //                  
    // ------------------------------------------------------------------------
    enum class EDrvCmdWaits
    {
        DontCare
        , Wait
        , NoWait
        , Count
        , Min = DontCare
        , Max = NoWait
    };
    CQCKITEXPORT EDrvCmdWaits eXlatEDrvCmdWaits(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEDrvCmdWaits(const EDrvCmdWaits eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadEDrvCmdWaits(const EDrvCmdWaits eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDrvCmdWaits eVal);

    
    // ------------------------------------------------------------------------
    //  Driver states. There are a number of states that a server side driver
    //  can be in, and it is tracked via a member of this type in the base
    //  server side class. This let's outsiders understand what's going on
    //  with drivers at a glance. The driver is loaded and it's init method
    //  is called. The init method can return either WaitConfig or WaitCommRes
    //  to indicate what it want's it's next state to be.
    //  
    //  These do have to be streamable, but not persisted. They are purely runtime
    //  values, so new values don't have to be added at the end.
    //  
    //  The meanings are:
    //  
    //  NotLoaded       - The driver is not loaded on the CQCServer that
    //                    was queried. This one is special and allows the
    //                    CQCServer to return a result instead of throwing
    //                    an exception if the state of an unloaded driver is
    //                    asked for.
    //  Failed          - We couldn't load the driver for some reason. We'll
    //                    just stay here until the user does something about
    //                    it.
    //  Paused          - It's loaded, but it's been paused by the user. It will
    //                    have been cleaned up, but not unloaded. If unpaused it
    //                    will be taken back through initialization and so forth
    //                    as though it was just loaded.
    //  WaitInit        - The driver is initializing. Normally this is a one
    //                    time thing since most drivers would never fail this
    //                    step, but sometimes they may and will stay in this
    //                    state until they successfully initialize.
    //  WaitConfig      - It requies some sort of user configuration and it
    //                    has not gotten any yet.
    //  WaitCommRes     - Waiting to get the communications resource, which
    //                    can often happen with things like removeable comm
    //                    ports.
    //  WaitConnect     - Waiting to get connected to the device it controls.
    //  Connected       - The driver is connected to it's device and working
    //                    normally.
    //  Terminated      - This is set after the driver's terminate call is
    //                    made. The outside world won't ever see it, since it
    //                    is removed from their view before termination.
    //                  
    // ------------------------------------------------------------------------
    enum class EDrvStates
    {
        NotLoaded
        , Failed
        , Paused
        , WaitInit
        , WaitConfig
        , WaitCommRes
        , WaitConnect
        , Connected
        , Terminated
        , Count
        , Min = NotLoaded
        , Max = Terminated
    };
    CQCKITEXPORT EDrvStates eXlatEDrvStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEDrvStates(const EDrvStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEDrvStates(const EDrvStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EDrvStates eAltXlatEDrvStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDrvStates eVal);

    
    // ------------------------------------------------------------------------
    //  The types of CQC drivers that can exist, i.e. how they are actually
    //  implemented, and therefore how they get loaded up and run.
    //                  
    // ------------------------------------------------------------------------
    enum class EDrvTypes
    {
        CppLib
        , Macro
        , GenProto
        , Count
        , Min = CppLib
        , Max = GenProto
    };
    CQCKITEXPORT const TString& strLoadEDrvTypes(const EDrvTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EDrvTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used to indicate what types of event processing an application wants
    //  to run.
    //                  
    // ------------------------------------------------------------------------
    enum class EEvProcTypes : tCIDLib::TCard1
    {
        Receive = 0x1
        , Send = 0x2
        , Both = 0x3
        , Count = 3
        , None = 0
        , AllBits = 0x3
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvProcTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The types that the event filter expression language supports.
    //                  
    // ------------------------------------------------------------------------
    enum class EEvFTypes
    {
        Boolean
        , Int4
        , Card4
        , Card8
        , Float8
        , String
        , Count
        , Min = Boolean
        , Max = String
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvFTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in field event trigger config, to indicate what type of latching,
    //  if any, should be used. Only used if it's an 'on expression' trigger
    //  type.
    //  
    //  These are persisted so add at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EEvTrLatches
    {
        Unlatched
        , Unidirectional
        , Bidirectional
        , Count
        , Min = Unlatched
        , Max = Bidirectional
    };
    CQCKITEXPORT const TString& strLoadEEvTrLatches(const EEvTrLatches eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvTrLatches eVal);

    
    // ------------------------------------------------------------------------
    //  Used in field event triggers at runtime, to remember the last latch
    //  state. We can't just use a boolean, since we never want to trigger the
    //  first time we get a good value, and subsequently we only trigger if
    //  the latch state changes. False and True are the last expression
    //  evaluation result.
    //  
    //                  
    // ------------------------------------------------------------------------
    enum class EEvTrLatchSts
    {
        First
        , False
        , True
        , Count
        , Min = First
        , Max = True
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvTrLatchSts eVal);

    
    // ------------------------------------------------------------------------
    //  Used in field event trigger config, to indicate if the trigger is just
    //  on any change, controlled by an expression, or not used.
    //  
    //  These are persisted so add at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EEvTrTypes
    {
        Unused
        , OnChange
        , OnExpression
        , Count
        , Min = Unused
        , Max = OnExpression
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvTrTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The types of CQC e-mail accounts we support for sending out or receiving
    //  e-mails. Add new ones at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EEMailTypes
    {
        Unused
        , SMTP
        , SMTPS
        , Count
        , Min = Unused
        , Max = SMTPS
    };
    CQCKITEXPORT EEMailTypes eXlatEEMailTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEEMailTypes(const EEMailTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEMailTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used to mark the current state of event monitors in the event server, and in
    //  configuration as far as running vs. paused. At runtime, we also use the
    //  failed state if it fails to load.
    //                  
    // ------------------------------------------------------------------------
    enum class EEvMonStates
    {
        Paused
        , Failed
        , Running
        , Count
        , Min = Paused
        , Max = Running
    };
    CQCKITEXPORT EEvMonStates eXlatEEvMonStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEEvMonStates(const EEvMonStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvMonStates eVal);

    
    // ------------------------------------------------------------------------
    //  In a number of places we support expressions that evaluate themselves
    //  relative to the value of an associated field. The expression is either
    //  a regular expression or one of the EStatements statements.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out
    //          to disk in saved user interfaces.
    //                  
    // ------------------------------------------------------------------------
    enum class EExprTypes
    {
        None
        , RegEx
        , Statement
        , Count
        , Min = None
        , Max = Statement
    };
    CQCKITEXPORT EExprTypes eXlatEExprTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEExprTypes(const EExprTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EExprTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The field access types available. NOTE that the order is important
    //  because it means that readable fields have the 0x1 bit set and
    //  writeable fields have the 0x2 bit set, None has neither, ReadWrite
    //  has both.
    //                  
    // ------------------------------------------------------------------------
    enum class EFldAccess
    {
        None
        , Read
        , Write
        , ReadWrite
        , Count
        , Min = None
        , Max = ReadWrite
    };
    CQCKITEXPORT EFldAccess eXlatEFldAccess(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEFldAccess(const EFldAccess eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEFldAccess(const EFldAccess eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EFldAccess eAltXlatEFldAccess(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EFldAccess eVal);

    
    // ------------------------------------------------------------------------
    //  In the second generation driver arcthitecture, each field can be marked
    //  with a 'semantic type', which indicates it's actual usage. Even in new
    //  style drivers, not all of them will be marked.
    //  
    //  NOTE:   If you update this let, the CML field definition class must be updated
    //          as well since it maps these types.
    //                  
    // ------------------------------------------------------------------------
    enum class EFldSTypes
    {
        AnalogIO
        , BoolSwitch
        , CatCookie
        , ChannelAdj
        , ClrLight
        , ColCookie
        , ContactClosure
        , CurChannel
        , CurExtHumidity
        , CurExtTemp
        , CurTemp
        , CurWeather
        , DigitalIO
        , Dimmer
        , DriverMoniker
        , Generic
        , HighSetPnt
        , HumSensor
        , ItemCookie
        , LEDStatus
        , LightSwitch
        , LowSetPnt
        , MediaCookie
        , MediaRepoDrv
        , MediaSrc
        , MediaState
        , MediaTransport
        , Mute
        , MotionSensor
        , Power
        , PowerState
        , Relay
        , RFIDTag
        , SecZoneStat
        , SourceInp
        , TempSensor
        , TitleCookie
        , TunerFreq
        , Volume
        , VolumeAdj
        , LockState
        , Count
        , Min = AnalogIO
        , Max = LockState
    };
    CQCKITEXPORT EFldSTypes eXlatEFldSTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEFldSTypes(const EFldSTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEFldSTypes(const EFldSTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EFldSTypes eAltXlatEFldSTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EFldSTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The field types supported by the generic read/write interfaces of
    //  device drivers.
    //  
    //  NOTE:   The CQC extensions of the macro engine have to provide equiv
    //          enums to the macro code, so keep that in sync if you make
    //          changes here! We set the display text to match the CML types.
    //                  
    // ------------------------------------------------------------------------
    enum class EFldTypes
    {
        Boolean
        , Card
        , Float
        , Int
        , String
        , StringList
        , Time
        , Count
        , Min = Boolean
        , Max = Time
    };
    CQCKITEXPORT EFldTypes eXlatEFldTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEFldTypes(const EFldTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEFldTypes(const EFldTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EFldTypes eAltXlatEFldTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EFldTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Allows some visual control over the interface viewer. Used by the
    //  DoStdFrameOp() method. Not persisted so order doesn't matter.
    //                  
    // ------------------------------------------------------------------------
    enum class EIVFrmOps
    {
        FSMode
        , Hide
        , Maximize
        , Minimize
        , Restore
        , Show
        , ToFront
        , ToBack
        , Count
        , Min = FSMode
        , Max = ToBack
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EIVFrmOps eVal);

    
    // ------------------------------------------------------------------------
    //  Each state is composed of a set of expressions, which are combined
    //  with one of these logical operations.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out
    //          to disk in saved interfaces.
    //                  
    // ------------------------------------------------------------------------
    enum class ELogOps
    {
        OR
        , AND
        , XOR
        , Count
        , Min = OR
        , Max = XOR
    };
    CQCKITEXPORT ELogOps eXlatELogOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatELogOps(const ELogOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatELogOps(const ELogOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT ELogOps eAltXlatELogOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TVoid FormatELogOps
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::AltText
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ELogOps eVal);

    
    // ------------------------------------------------------------------------
    //  The possible results a login attempt.
    //                  
    // ------------------------------------------------------------------------
    enum class ELoginRes
    {
        Ok
        , BadCred
        , TimeLimits
        , Limit
        , Exception
        , Count
        , Min = Ok
        , Max = Exception
    };
    CQCKITEXPORT ELoginRes eXlatELoginRes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatELoginRes(const ELoginRes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ELoginRes eVal);

    
    // ------------------------------------------------------------------------
    //  These are used to pass in some miscellaneous operations to the IV via the remote
    //  control interface (indirectly through the IV control driver.) These are not
    //  persisted so order doesn't really matter.
    //                  
    // ------------------------------------------------------------------------
    enum class EIVMiscOps
    {
        Blanker
        , BlankDisplay
        , BlankAndBlanker
        , ClockBlanker
        , ShowBlanker
        , Unblank
        , Count
        , Min = Blanker
        , Max = Unblank
    };
    CQCKITEXPORT EIVMiscOps eXlatEIVMiscOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEIVMiscOps(const EIVMiscOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEIVMiscOps(const EIVMiscOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EIVMiscOps eAltXlatEIVMiscOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EIVMiscOps eVal);

    
    // ------------------------------------------------------------------------
    //  Used in the driver packaging class, TCQCPackage, to indicate what
    //  type of package it contains.
    //  
    //  These are persisted so add at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EPackTypes
    {
        ProtocolDrv
        , CMLDrv
        , MacroBundle
        , ImgBundle
        , IntfTemplate
        , Count
        , Min = ProtocolDrv
        , Max = IntfTemplate
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EPackTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Used in the driver packaging class, TCQCPackage, to indicate the type
    //  of each file added to a package. Note that a 'file' might be just some
    //  blob of data generated on the fly and added to the package to aid in
    //  importing the package later, such as the DevMap.
    //  
    //  See the CQCKit_Package.hpp file comments for more on the format that
    //  these types represent in the package itself.
    //  
    //  If you add new items, be sure to update the package and package file
    //  classes, since they are dependent on this list.
    //  
    //  These are persisted so add at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EPackFlTypes
    {
        Manifest
        , CMLMacro
        , PDLFile
        , PNGImage
        , IntfTmpl
        , DevMap
        , Count
        , Min = Manifest
        , Max = DevMap
    };
    CQCKITEXPORT EPackFlTypes eXlatEPackFlTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEPackFlTypes(const EPackFlTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadEPackFlTypes(const EPackFlTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EPackFlTypes eVal);

    
    // ------------------------------------------------------------------------
    //  Represents the standard V2 PWR#Status field values. It's an enumerated string
    //  field that has these values.
    //                  
    // ------------------------------------------------------------------------
    enum class EPowerStatus
    {
        Off
        , Starting
        , Ready
        , Stopping
        , Failed
        , Count
        , Min = Off
        , Max = Failed
    };
    CQCKITEXPORT EPowerStatus eXlatEPowerStatus(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEPowerStatus(const EPowerStatus eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EPowerStatus eVal);

    
    // ------------------------------------------------------------------------
    //  Used in the driver config object, for prompted values, to indicate
    //  what type of prompted value it is.
    //  
    //  These are persisted so add at the end!
    //                  
    // ------------------------------------------------------------------------
    enum class EPromptTypes
    {
        Bool
        , List
        , Text
        , Range
        , TrayMonBinding
        , Path
        , File
        , RepoDriver
        , MultiList
        , ODBCSrc
        , AudioDev
        , TTSVoice
        , NamedMList
        , Count
        , Min = Bool
        , Max = NamedMList
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EPromptTypes eVal);

    
    // ------------------------------------------------------------------------
    //  This is used by any programs (such as CQCVoice) that provide spoken feedback and
    //  also want to possibly make it work for the visually impaired. It is a bitmapped
    //  value although we don't mark it as one (so that we can do interation.) Since it's
    //  only three values, they still remain continuous.
    //  
    //  These are stored so add new ones to the end.
    //  
    //                  
    // ------------------------------------------------------------------------
    enum class EReplyStyles
    {
        None
        , Visual
        , Spoken
        , Both
        , Count
        , Min = None
        , Max = Both
    };
    CQCKITEXPORT EReplyStyles eXlatEReplyStyles(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEReplyStyles(const EReplyStyles eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEReplyStyles(const EReplyStyles eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EReplyStyles eAltXlatEReplyStyles(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EReplyStyles eVal);

    
    // ------------------------------------------------------------------------
    //  This is used by widgets to indicate what field access types they must
    //  have and can have.
    //  
    //  It's also used in the command system, where commands can mark
    //  themselves as to field access. This way, the command editing dialog
    //  knows what fields to present for a field based parameter.
    //  
    //  And it's used in the device class class, to indicate required access.
    //  
    //  They are arranged in numeric order.
    //                  
    // ------------------------------------------------------------------------
    enum class EReqAccess : tCIDLib::TCard4
    {
        CanRead = 0x0001
        , CanWrite = 0x0002
        , ReadOrWrite = 0x0003
        , MustRead = 0x0004
        , ReadOnly = 0x0005
        , MReadCWrite = 0x0007
        , MustWrite = 0x0008
        , WriteOnly = 0x000A
        , CReadMWrite = 0x000B
        , ReadAndWrite = 0x000F
        , Count = 10
        , None = 0
        , AllBits = 0xF
    };
    CQCKITEXPORT EReqAccess eXlatEReqAccess(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEReqAccess(const EReqAccess eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadEReqAccess(const EReqAccess eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strAltXlatEReqAccess(const EReqAccess eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EReqAccess eAltXlatEReqAccess(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TVoid FormatEReqAccess
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EReqAccess eVal);

    
    // ------------------------------------------------------------------------
    //  The types of scheduling a scheduled event can have. These are persisted so
    //  put new ones at the end!
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out to
    //          disk.
    //                  
    // ------------------------------------------------------------------------
    enum class ESchTypes
    {
        Once
        , Daily
        , Weekly
        , Monthly
        , MinPeriod
        , HrPeriod
        , DayPeriod
        , Sunrise
        , Sunset
        , Count
        , Min = Once
        , Max = Sunset
    };
    CQCKITEXPORT ESchTypes eXlatESchTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatESchTypes(const ESchTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadESchTypes(const ESchTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ESchTypes eVal);

    
    // ------------------------------------------------------------------------
    //  An enum used for screen navigation. Currently it's only used in
    //  the IV's remote control interface, but might be used in other places
    //  so it's defined here where they can all see it.
    //  
    //  It's done here because it may also be used by background drivers that
    //  send out or respond to such commands (instead of in one of the GUI
    //  related facilities.)
    //                  
    // ------------------------------------------------------------------------
    enum class EScrNavOps
    {
        Back
        , Down
        , End
        , Home
        , Left
        , Prev
        , PrevPage
        , Next
        , NextPage
        , Right
        , Up
        , Count
        , Min = Back
        , Max = Up
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EScrNavOps eVal);

    
    // ------------------------------------------------------------------------
    //  The statement types supported by the user drawn interface system. They
    //  must be defined here, because it uses the simple field value classes
    //  provided by us, and that class provides an API to test a statement
    //  against itself. We also define an enum that is returned from statement
    //  evaluation by the field value classes.
    //  
    //  These are persisted so new ones must be added at the end.
    //                  
    // ------------------------------------------------------------------------
    enum class EStatements
    {
        None
        , IsEqual
        , NotEqual
        , IsTrue
        , IsFalse
        , IsGThan
        , IsGThanEq
        , IsLsThan
        , IsLsThanEq
        , IsNonNull
        , IsNegative
        , IsPositive
        , IsEven
        , IsOdd
        , IsMultipleOf
        , IsAlpha
        , IsAlphaNum
        , Count
        , Min = None
        , Max = IsAlphaNum
        , FirstUsed = IsEqual
    };
    CQCKITEXPORT EStatements eXlatEStatements(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEStatements(const EStatements eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EStatements eVal);

    
    // ------------------------------------------------------------------------
    //  These are used in expression statement evaluation in the user
    //  interface system. Each statement evalutes the value of an associated
    //  field, and idicates that the statement is either true, false, that
    //  the field had a bad value, or the statement was not well formed.
    //                  
    // ------------------------------------------------------------------------
    enum class EStmtRes
    {
        True
        , False
        , BadValue
        , BadStatement
        , Count
        , Min = True
        , Max = BadStatement
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EStmtRes eVal);

    
    // ------------------------------------------------------------------------
    //  A common set of standard windowed app operations, used by the app
    //  control server's client proxy class, which is part of CQCKit.
    //                  
    // ------------------------------------------------------------------------
    enum class EStdACOps
    {
        Maximize
        , Minimize
        , Restore
        , ToTop
        , ToBack
        , Count
        , Min = Maximize
        , Max = ToBack
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EStdACOps eVal);

    
    // ------------------------------------------------------------------------
    //  These values represent a set of standard driver events that device drivers
    //  can send out. Which types of drivers send which ones is defined by the driver
    //  device classes that the driver implements. They all take just a couple values
    //  to send with the event and there's a method in the driver base class to send
    //  them easily. Some are only sent if the driver is configured to do so, such as
    //  field change events.
    //  
    //  The enum text is the name of the event type so it can be used on the sending
    //  and filtering sides.
    //  
    //  !!!!There is a table in CQCKit_Event.cpp which is used to simplify dealing with
    //  these events. Be sure to update it if you change this list! Otherwise the
    //  order isn't important since they are not persisted.
    //                  
    // ------------------------------------------------------------------------
    enum class EStdDrvEvs
    {
        FldChange
        , LoadChange
        , LockStatus
        , Motion
        , Presence
        , UserAction
        , ZoneAlarm
        , Count
        , Min = FldChange
        , Max = ZoneAlarm
    };
    CQCKITEXPORT EStdDrvEvs eXlatEStdDrvEvs(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEStdDrvEvs(const EStdDrvEvs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadEStdDrvEvs(const EStdDrvEvs eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EStdDrvEvs eVal);

    
    // ------------------------------------------------------------------------
    //  Every driver gets a set of standard fields which are added by the
    //  driver itself on their behalf. Most are used to hold 'instrumentation
    //  data' stuff, such as how many bad messages has the driver seen, how
    //  many times has it lost connection with it's device, and so forth. The
    //  base driver class provides APIs to bump these counters so that drivers
    //  don't have to be concerned with the details, but by their being fields,
    //  they become available to clients via standard mechanisms. Some of them
    //  will be totally handled by the base driver itself, and for others
    //  the base driver class provides APIs to increment them. Some just expose
    //  some useful info like current verbosity leve and load time.
    //  
    //  NOTE:   Add new ones at the END, because this enum is compiled into drivers.
    //                  
    // ------------------------------------------------------------------------
    enum class EStdFields
    {
        BadMsgs
        , FailedWrites
        , LoadTime
        , LostCommRes
        , LostConn
        , Naks
        , Reconfigs
        , Timeouts
        , UnknownMsgs
        , UnknownWrites
        , Verbosity
        , Count
        , Min = BadMsgs
        , Max = Verbosity
    };
    CQCKITEXPORT EStdFields eXlatEStdFields(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEStdFields(const EStdFields eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEStdFields(const EStdFields eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EStdFields eAltXlatEStdFields(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EStdFields eVal);

    
    // ------------------------------------------------------------------------
    //  The types of filters we provide, for deciding if a triggered event
    //  should be triggered for a given incoming event. The _Arbitrary type
    //  allows the user to check any arbitrary event field for a given value.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out to
    //          disk.
    //  NOTE:   The triggered event filter window displays some instruction text
    //          based on the type, so update that if you change this list.
    //                  
    // ------------------------------------------------------------------------
    enum class ETEvFilters
    {
        Unused
        , Arbitrary
        , FldValEquals
        , IsDevReady
        , IsFieldChange
        , IsFieldChangeFor
        , IsFromSource
        , IsNewFldValFor
        , IsInTimeRange
        , IsNight
        , IsOfClass
        , IsUserAction
        , IsUserActionFor
        , IsUserActionFrom
        , IsThisUserAction
        , IsLoadChange
        , IsLoadChangeFor
        , IsLoadChangeFrom
        , IsLoadChangeOn
        , IsLoadChangeOff
        , IsMotionEv
        , IsMotionEvFor
        , IsMotionEvFrom
        , IsMotionStartEv
        , IsMotionEndEv
        , IsZoneAlarm
        , IsZoneAlarmFor
        , IsZoneAlarmFrom
        , IsZoneViolated
        , IsZoneSecured
        , IsWeekDay
        , IsPresenceEv
        , IsPresenceEvFrom
        , IsPresenceEvInArea
        , IsLockStatus
        , IsLockStatusFrom
        , IsLockStatusCode
        , Count
        , Min = Unused
        , Max = IsLockStatusCode
    };
    CQCKITEXPORT ETEvFilters eXlatETEvFilters(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatETEvFilters(const ETEvFilters eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ETEvFilters eVal);

    
    // ------------------------------------------------------------------------
    //  A logical operator enum that is used for filtering incoming filters.
    //  The TEvFilters enum above is used to set up a list of filters. This
    //  controls how the results are combined.
    //  
    //  NOTE:   Add new ones at the END, because this enum is streamed out to
    //          disk.
    //                  
    // ------------------------------------------------------------------------
    enum class ETEvFiltLOps
    {
        AND
        , OR
        , XOR
        , Count
        , Min = AND
        , Max = XOR
    };
    CQCKITEXPORT ETEvFiltLOps eXlatETEvFiltLOps(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatETEvFiltLOps(const ETEvFiltLOps eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const ETEvFiltLOps eVal);

    
    // ------------------------------------------------------------------------
    //  The types of event related entities supported by the event server, mostly used
    //  in the ORB API to the event server for management of these things.
    //  
    //  These aren't currently persisted so order and value can change across CQC releases.
    //                  
    // ------------------------------------------------------------------------
    enum class EEvSrvTypes
    {
        None
        , EvMonitor
        , TrgEvent
        , SchEvent
        , Count
        , Min = None
        , Max = SchEvent
    };
    CQCKITEXPORT EEvSrvTypes eXlatEEvSrvTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEEvSrvTypes(const EEvSrvTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEEvSrvTypes(const EEvSrvTypes eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EEvSrvTypes eAltXlatEEvSrvTypes(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EEvSrvTypes eVal);

    
    // ------------------------------------------------------------------------
    //  We mark some user accounts as special types, which is separate from the
    //  the user role. User roles manage rights, whereas the types are used for
    //  other things.
    //  
    //  Standard     - Just a regular user account
    //  SecServer    - An account used by secondary servers to log in.
    //                  
    // ------------------------------------------------------------------------
    enum class EUserTypes
    {
        Standard
        , SecServer
        , Count
        , Min = Standard
        , Max = SecServer
    };
    CQCKITEXPORT tCIDLib::TVoid FormatEUserTypes
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Name
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EUserTypes eVal);

    
    // ------------------------------------------------------------------------
    //  The defined user roles. They are arranged so that higher numerical
    //  values represent more rights.
    //                  
    // ------------------------------------------------------------------------
    enum class EUserRoles
    {
        LimitedUser
        , NormalUser
        , PowerUser
        , SystemAdmin
        , Count
        , Min = LimitedUser
        , Max = SystemAdmin
    };
    CQCKITEXPORT EUserRoles eXlatEUserRoles(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEUserRoles(const EUserRoles eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strLoadEUserRoles(const EUserRoles eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strAltXlatEUserRoles(const EUserRoles eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EUserRoles eAltXlatEUserRoles(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TVoid FormatEUserRoles
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EUserRoles eVal);

    
    // ------------------------------------------------------------------------
    //  The results of validating a value against a field's type/limits
    //                  
    // ------------------------------------------------------------------------
    enum class EValResults
    {
        OK
        , Unchanged
        , Unconvertable
        , LimitViolation
        , Count
        , Min = OK
        , Max = LimitViolation
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EValResults eVal);

    
    // ------------------------------------------------------------------------
    //  A common type of result from a value query, where the value might not
    //  be available, might not have chagned since the last time, it might have
    //  changed, or it might be found but in error.
    //                  
    // ------------------------------------------------------------------------
    enum class EValQRes
    {
        NotFound
        , NoChange
        , NewValue
        , InError
        , Reconfig
        , Count
        , Min = NotFound
        , Max = Reconfig
    };
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EValQRes eVal);

    
    // ------------------------------------------------------------------------
    //  The levels of logging verbosity that can be set on CQC device drivers.
    //                  
    // ------------------------------------------------------------------------
    enum class EVerboseLvls
    {
        Off
        , Low
        , Medium
        , High
        , Count
        , Min = Off
        , Max = High
    };
    CQCKITEXPORT EVerboseLvls eXlatEVerboseLvls(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEVerboseLvls(const EVerboseLvls eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EVerboseLvls eVal);

    
    // ------------------------------------------------------------------------
    //  These are the zone states used in the standard V2 zone status field, and in the
    //  zone alarm triggers sent out when zone states change, though only the first four
    //  are sent out as triggers. The value sent in the triggers is the alt text.
    //  
    //  The order is important. Some drivers depend on this to efficiently map from the
    //  device status bits to the enum.
    //                  
    // ------------------------------------------------------------------------
    enum class EZoneStates
    {
        Secure
        , NotReady
        , Violated
        , Bypassed
        , Unknown
        , Count
        , Min = Secure
        , Max = Unknown
    };
    CQCKITEXPORT EZoneStates eXlatEZoneStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT const TString& strXlatEZoneStates(const EZoneStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT const TString& strAltXlatEZoneStates(const EZoneStates eToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::True);
    CQCKITEXPORT EZoneStates eAltXlatEZoneStates(const TString& strToXlat, const tCIDLib::TBoolean bThrowIfNot = kCIDLib::False);
    CQCKITEXPORT tCIDLib::TVoid FormatEZoneStates
        (
                         TString&            strTarget
              , const    TString&            strPrefix
              , const    tCIDLib::TCh        chSepChar
              , const    TEnumMap::ETextVals eVal = TEnumMap::ETextVals::Text
        );
    CQCKITEXPORT tCIDLib::TBoolean bIsValidEnum(const EZoneStates eVal);

}

#pragma CIDLIB_POPPACK

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EActCmdCtx eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EActCmdCtx& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EActCmdCtx* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EActCmdCtx* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EActOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EActOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EActOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EActOps* const aeList, const tCIDLib::TCard4 c4Count);



CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ECmdPTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ECmdPTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ECmdPTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ECmdPTypes* const aeList, const tCIDLib::TCard4 c4Count);


CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ECommResults eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ECommResults& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ECommResults* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ECommResults* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::ECommResults eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EDevCats eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EDevCats& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EDevCats* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EDevCats* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EDevCats operator++(tCQCKit::EDevCats& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EDevCats eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EDevClasses eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EDevClasses& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EDevClasses* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EDevClasses* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EDevClasses operator++(tCQCKit::EDevClasses& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EDevClasses eToStream);


CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EDrvCmdWaits eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EDrvCmdWaits& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EDrvCmdWaits* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EDrvCmdWaits* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EDrvCmdWaits eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EDrvStates eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EDrvStates& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EDrvStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EDrvStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EDrvStates eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EDrvTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EDrvTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EDrvTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EDrvTypes* const aeList, const tCIDLib::TCard4 c4Count);

constexpr tCQCKit::EEvProcTypes operator|(const tCQCKit::EEvProcTypes eLHS, const tCQCKit::EEvProcTypes eRHS)
{    
    return tCQCKit::EEvProcTypes(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCKit::EEvProcTypes& operator|=(tCQCKit::EEvProcTypes& eLHS, const tCQCKit::EEvProcTypes eRHS)
{    
    eLHS = tCQCKit::EEvProcTypes(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
constexpr tCQCKit::EEvProcTypes operator&(const tCQCKit::EEvProcTypes eLHS, const tCQCKit::EEvProcTypes eRHS)
{    
    return tCQCKit::EEvProcTypes(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCKit::EEvProcTypes& operator&=(tCQCKit::EEvProcTypes& eLHS, const tCQCKit::EEvProcTypes eRHS)
{    
    eLHS = tCQCKit::EEvProcTypes(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}

CQCKITEXPORT tCQCKit::EEvFTypes operator++(tCQCKit::EEvFTypes& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EEvTrLatches eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EEvTrLatches& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EEvTrLatches* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EEvTrLatches* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EEvTrLatches operator++(tCQCKit::EEvTrLatches& eVal, int);


CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EEvTrTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EEvTrTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EEvTrTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EEvTrTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EEMailTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EEMailTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EEMailTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EEMailTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EEMailTypes operator++(tCQCKit::EEMailTypes& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EEvMonStates eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EEvMonStates& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EEvMonStates* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EEvMonStates* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EExprTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EExprTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EExprTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EExprTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EFldAccess eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EFldAccess& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EFldAccess* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EFldAccess* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EFldAccess eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EFldSTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EFldSTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EFldSTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EFldSTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EFldSTypes eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EFldTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EFldTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EFldTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EFldTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EFldTypes operator++(tCQCKit::EFldTypes& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EFldTypes eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EIVFrmOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EIVFrmOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EIVFrmOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EIVFrmOps* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ELogOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ELogOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ELogOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ELogOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::ELogOps operator++(tCQCKit::ELogOps& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ELoginRes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ELoginRes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ELoginRes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ELoginRes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::ELoginRes eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EIVMiscOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EIVMiscOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EIVMiscOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EIVMiscOps* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EPackTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EPackTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EPackTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EPackTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EPackFlTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EPackFlTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EPackFlTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EPackFlTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EPowerStatus eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EPowerStatus& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EPowerStatus* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EPowerStatus* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EPowerStatus operator++(tCQCKit::EPowerStatus& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EPowerStatus eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EPromptTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EPromptTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EPromptTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EPromptTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EReplyStyles eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EReplyStyles& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EReplyStyles* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EReplyStyles* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EReplyStyles operator++(tCQCKit::EReplyStyles& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EReqAccess eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EReqAccess& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EReqAccess* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EReqAccess* const aeList, const tCIDLib::TCard4 c4Count);
constexpr tCQCKit::EReqAccess operator|(const tCQCKit::EReqAccess eLHS, const tCQCKit::EReqAccess eRHS)
{    
    return tCQCKit::EReqAccess(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCKit::EReqAccess& operator|=(tCQCKit::EReqAccess& eLHS, const tCQCKit::EReqAccess eRHS)
{    
    eLHS = tCQCKit::EReqAccess(tCIDLib::TEnumMaskType(eLHS) | tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}
constexpr tCQCKit::EReqAccess operator&(const tCQCKit::EReqAccess eLHS, const tCQCKit::EReqAccess eRHS)
{    
    return tCQCKit::EReqAccess(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
}
constexpr tCQCKit::EReqAccess& operator&=(tCQCKit::EReqAccess& eLHS, const tCQCKit::EReqAccess eRHS)
{    
    eLHS = tCQCKit::EReqAccess(tCIDLib::TEnumMaskType(eLHS) & tCIDLib::TEnumMaskType(eRHS));
    return eLHS;
}

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ESchTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ESchTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ESchTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ESchTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::ESchTypes operator++(tCQCKit::ESchTypes& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EScrNavOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EScrNavOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EScrNavOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EScrNavOps* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EStatements eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EStatements& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EStatements* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EStatements* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EStatements operator++(tCQCKit::EStatements& eVal, int);


CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EStdACOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EStdACOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EStdACOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EStdACOps* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT tCQCKit::EStdDrvEvs operator++(tCQCKit::EStdDrvEvs& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EStdFields eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EStdFields& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EStdFields* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EStdFields* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EStdFields operator++(tCQCKit::EStdFields& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EStdFields eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ETEvFilters eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ETEvFilters& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ETEvFilters* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ETEvFilters* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::ETEvFilters operator++(tCQCKit::ETEvFilters& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::ETEvFilters eToStream);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::ETEvFiltLOps eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::ETEvFiltLOps& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::ETEvFiltLOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::ETEvFiltLOps* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::ETEvFiltLOps operator++(tCQCKit::ETEvFiltLOps& eVal, int);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EEvSrvTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EEvSrvTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EEvSrvTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EEvSrvTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EUserTypes eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EUserTypes& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EUserTypes* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EUserTypes* const aeList, const tCIDLib::TCard4 c4Count);

CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EUserRoles eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EUserRoles& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EUserRoles* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EUserRoles* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EUserRoles operator++(tCQCKit::EUserRoles& eVal, int);
CQCKITEXPORT TTextOutStream& operator<<(TTextOutStream& strmTar, const tCQCKit::EUserRoles eToStream);



CQCKITEXPORT TBinOutStream& operator<<(TBinOutStream& strmTar, const tCQCKit::EVerboseLvls eToStream);
CQCKITEXPORT TBinInStream& operator>>(TBinInStream& strmSrc, tCQCKit::EVerboseLvls& eToFill);
CQCKITEXPORT tCIDLib::TVoid TBinInStream_ReadArray(TBinInStream& strmSrc, tCQCKit::EVerboseLvls* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCIDLib::TVoid TBinOutStream_WriteArray(TBinOutStream& strmTar, const tCQCKit::EVerboseLvls* const aeList, const tCIDLib::TCard4 c4Count);
CQCKITEXPORT tCQCKit::EVerboseLvls operator++(tCQCKit::EVerboseLvls& eVal, int);

CQCKITEXPORT tCQCKit::EZoneStates operator++(tCQCKit::EZoneStates& eVal, int);

