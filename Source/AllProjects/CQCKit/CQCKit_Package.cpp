//
// FILE NAME: CQCKit_Package.cpp
//
// AUTHOR: Dean Roddey
//
// CREATED: 01/05/2004
//
// COPYRIGHT: Charmed Quark Systems, Ltd @ 2020
//
//  This software is copyrighted by 'Charmed Quark Systems, Ltd' and
//  the author (Dean Roddey.) It is licensed under the MIT Open Source
//  license:
//
//  https://opensource.org/licenses/MIT
//
// DESCRIPTION:
//
//  This file implements the driver packaging classes, one represents individual files,
//  and the other the overall package.
//
// CAVEATS/GOTCHAS:
//
// LOG:
//
//  $Log$
//


// ---------------------------------------------------------------------------
//  Includes
// ---------------------------------------------------------------------------
#include    "CQCKit_.hpp"


// ---------------------------------------------------------------------------
//  Magic Macros
// ---------------------------------------------------------------------------
RTTIDecls(TCQCPackageFl,TObject)
RTTIDecls(TCQCPackage,TObject)
EnumBinStreamMacros(TCQCPackageFl::EFmtTypes)



// ---------------------------------------------------------------------------
//  Local data
// ---------------------------------------------------------------------------
namespace
{
    namespace CQCKit_DriverPack
    {
        // -----------------------------------------------------------------------
        //  Our current format version for the individual package file class.
        //
        //  Version 2 -
        //      Added the m_strUserData field, so that clients can add some extra
        //      marker type info for a file, which just makes sense to them and is
        //      used for their needs.
        //
        //  Version 3 -
        //      Added the ability to indicate whether a file should be stored
        //      encrypted when it's unpacked and stored.
        //
        //  Version 4 -
        //      Upgrade for 5.x file path format changes
        //
        //  Version 5 -
        //      Just changed so that we know whether a package was created before or after
        //      the switch over to the TChunkedFile format. There's no actual on disk format
        //      change for our own data, just the format of the data we store for the
        //      creating application.
        // -----------------------------------------------------------------------
        constexpr tCIDLib::TCard2   c2FileFmtVersion    = 5;


        // -----------------------------------------------------------------------
        //  Our current format version for the overall package class
        //
        //  Version 2 -
        //      Added the m_strUserData field, so that clients can add some extra
        //      marker type info for a file, which just makes sense to them and is
        //      used for their needs.
        // -----------------------------------------------------------------------
        constexpr tCIDLib::TCard2   c2PackFmtVersion    = 2;


        // -----------------------------------------------------------------------
        //  The magic value we put at the head of the file to indicate that it
        //  is a driver package.
        // -----------------------------------------------------------------------
        constexpr tCIDLib::TCard4   c4MagicVal      = 0xF8E7A1B2;


        // -----------------------------------------------------------------------
        //  The overall package format version. This is to let us later perhaps
        //  have a compressed payload. So it doesn't need to change just because
        //  the package class streaming changes, just if the overall storage
        //  format of the package were to change.
        //
        //  We bumped the version for our 2.0 release, to allow us to tell the
        //  difference between stuff generated by pre-2.0 versions because every
        //  thing has changed and no package could be valid.
        // -----------------------------------------------------------------------
        constexpr tCIDLib::TCard2   c2FmtVersion = 3;
    }
}




// ---------------------------------------------------------------------------
//   CLASS: TCQCPackageFl
//  PREFIX: pfl
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
//  TCQCPackageFl: Constructors and Destructor
// ---------------------------------------------------------------------------

//
//  In this ctor, it's assumed that a file will be streamed into this object
//  which will set the file type.
//
TCQCPackageFl::TCQCPackageFl(const tCIDLib::TBoolean bCompress) :

    m_bIsChunked(kCIDLib::True)
    , m_bCompress(bCompress)
    , m_bEncrypt(kCIDLib::False)
    , m_c4Size(0)
    , m_eFileType(tCQCKit::EPackFlTypes::Count)
    , m_eFmtType(EFmtTypes::Binary)
{
}

TCQCPackageFl::TCQCPackageFl(const  tCQCKit::EPackFlTypes   eType
                            , const TString&                strFileName
                            , const TChunkedFile&           chflData
                            , const tCIDLib::TBoolean       bCompress
                            , const tCIDLib::TBoolean       bEncrypt) :
    m_bCompress(bCompress)
    , m_bEncrypt(bEncrypt)
    , m_bIsChunked(kCIDLib::True)
    , m_c4Size(0)
    , m_eFileType(eType)
    , m_eFmtType(EFmtTypes::Binary)
    , m_mbufData(chflData.c4FullSzEstimate(), chflData.c4FullSzEstimate() + 8192)
    , m_strName(strFileName)
{
    // Flatten the chunked file out into or buffer
    TBinMBufOutStream strmTar(&m_mbufData);
    strmTar << chflData << kCIDLib::FlushIt;
    m_c4Size = strmTar.c4CurSize();
}


//
//  Can be used for text based based special stuff, like the device map. But it's
//  not for text based stuff from the data server (like macros.) Those are stored as
//  chunked files using the above ctor.
//
TCQCPackageFl::TCQCPackageFl(const  tCQCKit::EPackFlTypes   eType
                            , const TString&                strFileName
                            , const TString&                strText
                            , const tCIDLib::TBoolean       bCompress
                            , const tCIDLib::TBoolean       bEncrypt) :
    m_bCompress(bCompress)
    , m_bEncrypt(bEncrypt)
    , m_eFileType(eType)
    , m_eFmtType(EFmtTypes::Text)
    , m_strName(strFileName)
{
    // Stream it to our memory buffer
    TBinMBufOutStream strmOut(&m_mbufData);

    strmOut << strText << kCIDLib::FlushIt;
    m_c4Size = strmOut.c4CurSize();
}

//
//  In some cases we just want to store a binary blob, like for manifests, which
//  could be text but have a specific encoding and we want to keep it as is.
//
TCQCPackageFl::TCQCPackageFl(const  tCQCKit::EPackFlTypes   eType
                            , const TString&                strFileName
                            , const TMemBuf&                mbufData
                            , const tCIDLib::TCard4         c4Bytes
                            , const tCIDLib::TBoolean       bCompress
                            , const tCIDLib::TBoolean       bEncrypt) :
    m_bCompress(bCompress)
    , m_bEncrypt(bEncrypt)
    , m_c4Size(c4Bytes)
    , m_eFileType(eType)
    , m_eFmtType(EFmtTypes::Binary)
    , m_mbufData(c4Bytes, c4Bytes)
    , m_strName(strFileName)
{
    m_mbufData.CopyIn(mbufData, c4Bytes);
}

TCQCPackageFl::TCQCPackageFl(const TCQCPackageFl& pflSrc) :

    m_bCompress(pflSrc.m_bCompress)
    , m_bEncrypt(pflSrc.m_bEncrypt)
    , m_bIsChunked(pflSrc.m_bIsChunked)
    , m_c4Size(pflSrc.m_c4Size)
    , m_eFileType(pflSrc.m_eFileType)
    , m_eFmtType(pflSrc.m_eFmtType)
    , m_mbufData(pflSrc.m_mbufData)
    , m_strName(pflSrc.m_strName)
    , m_strUserData(pflSrc.m_strUserData)
{
}

// Do minimial setup and call move operator
TCQCPackageFl::TCQCPackageFl(TCQCPackageFl&& pflSrc) :

    m_bCompress(kCIDLib::False)
    , m_bEncrypt(kCIDLib::False)
    , m_bIsChunked(kCIDLib::False)
    , m_c4Size(0)
    , m_eFileType(tCQCKit::EPackFlTypes::Count)
    , m_eFmtType(EFmtTypes::Binary)
    , m_mbufData(1, 1)
{
    *this = tCIDLib::ForceMove(pflSrc);
}

TCQCPackageFl::~TCQCPackageFl()
{
}


// ---------------------------------------------------------------------------
//  TCQCPackageFl: Public operators
// ---------------------------------------------------------------------------
TCQCPackageFl& TCQCPackageFl::operator=(const TCQCPackageFl& pflSrc)
{
    if (this != &pflSrc)
    {
        m_bCompress     = pflSrc.m_bCompress;
        m_bEncrypt      = pflSrc.m_bEncrypt;
        m_bIsChunked    = pflSrc.m_bIsChunked;
        m_c4Size        = pflSrc.m_c4Size;
        m_eFileType     = pflSrc.m_eFileType;
        m_eFmtType      = pflSrc.m_eFmtType;
        m_mbufData      = pflSrc.m_mbufData;
        m_strName       = pflSrc.m_strName;
        m_strUserData   = pflSrc.m_strUserData;
    }
    return *this;
}

TCQCPackageFl& TCQCPackageFl::operator=(TCQCPackageFl&& pflSrc)
{
    if (this != &pflSrc)
    {
        tCIDLib::Swap(m_bCompress, pflSrc.m_bCompress);
        tCIDLib::Swap(m_bEncrypt, pflSrc.m_bEncrypt);
        tCIDLib::Swap(m_bIsChunked, pflSrc.m_bIsChunked);
        tCIDLib::Swap(m_c4Size, pflSrc.m_c4Size);
        tCIDLib::Swap(m_eFileType, pflSrc.m_eFileType);
        tCIDLib::Swap(m_eFmtType, pflSrc.m_eFmtType);

        m_mbufData      = tCIDLib::ForceMove(pflSrc.m_mbufData);
        m_strName       = tCIDLib::ForceMove(pflSrc.m_strName);
        m_strUserData   = tCIDLib::ForceMove(pflSrc.m_strUserData);
    }
    return *this;
}


// ---------------------------------------------------------------------------
//  TCQCPackageFl: Public, non-virtual methods
// ---------------------------------------------------------------------------

// Get/set the compress flag for this file
tCIDLib::TBoolean TCQCPackageFl::bCompress() const
{
    return m_bCompress;
}

tCIDLib::TBoolean TCQCPackageFl::bCompress(const tCIDLib::TBoolean bToSet)
{
    m_bCompress = bToSet;
    return m_bCompress;
}


// Get/set the encrypt flag for this file
tCIDLib::TBoolean TCQCPackageFl::bEncrypt() const
{
    return m_bEncrypt;
}

tCIDLib::TBoolean TCQCPackageFl::bEncrypt(const tCIDLib::TBoolean bToSet)
{
    m_bEncrypt = bToSet;
    return m_bEncrypt;
}


const THeapBuf& TCQCPackageFl::mbufData() const
{
    return m_mbufData;
}


// Set/get the user data field
const TString& TCQCPackageFl::strUserData() const
{
    return m_strUserData;
}

const TString& TCQCPackageFl::strUserData(const TString& strToSet)
{
    m_strUserData = strToSet;
    return m_strUserData;
}


// Set the data for this file
tCIDLib::TVoid
TCQCPackageFl::SetData( const   TString&        strFileName
                        , const TMemBuf&        mbufData
                        , const tCIDLib::TCard4 c4DataSz)
{
    // Anything new has to be chunked format
    m_bIsChunked = kCIDLib::True;

    m_strName = strFileName;
    m_mbufData.CopyIn(mbufData, c4DataSz);
    m_c4Size = c4DataSz;
}


// ---------------------------------------------------------------------------
//  TCQCPackageFl: Protected, inherited methods
// ---------------------------------------------------------------------------
tCIDLib::TVoid TCQCPackageFl::StreamFrom(TBinInStream& strmToReadFrom)
{
    // Make sure we get the start marker
    strmToReadFrom.CheckForStartMarker(CID_FILE, CID_LINE);

    // Stream in the format version and make sure its good.
    tCIDLib::TCard2 c2FmtVersion;
    strmToReadFrom  >> c2FmtVersion;
    if (!c2FmtVersion || (c2FmtVersion > CQCKit_DriverPack::c2FileFmtVersion))
    {
        facCIDLib().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kCIDErrs::errcGen_UnknownFmtVersion
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
            , TCardinal(c2FmtVersion)
            , clsThis()
        );
    }

    tCIDLib::TCard4 c4CheckSum;
    strmToReadFrom  >> c4CheckSum
                    >> m_eFileType
                    >> m_eFmtType
                    >> m_strName
                    >> m_bCompress
                    >> m_c4Size;

    // If version 2 or more, read the user data, else default it
    if (c2FmtVersion >= 2)
        strmToReadFrom >> m_strUserData;
    else
        m_strUserData.Clear();

    // If version 3 or greater, read in the encrypted flag, else default it
    if (c2FmtVersion >= 3)
        strmToReadFrom >> m_bEncrypt;
    else
        m_bEncrypt = kCIDLib::False;

    // Adjust the paths to 5.x style paths as required.
    if (c2FmtVersion < 4)
    {
        if (m_eFileType == tCQCKit::EPackFlTypes::CMLMacro)
        {
            if (m_strName.bStartsWithI(L"\\MEng"))
                m_strName.Cut(0, 5);
            facCQCKit().Make50Path(m_strName);
        }
         else if (m_eFileType == tCQCKit::EPackFlTypes::IntfTmpl)
        {
            // These at one point were non-hierarchical, so check for that as well
            if (!m_strName.bStartsWith(L"\\"))
                m_strName.Prepend(L"\\User\\");
            facCQCKit().Make50Path(m_strName);
        }
         else if (m_eFileType == tCQCKit::EPackFlTypes::PNGImage)
        {
            facCQCKit().Make50Path(m_strName);
        }
    }

    //
    //  Set the chunked flag based on whether it's something written out before or after
    //  we adopted the chunked file format.
    //
    m_bIsChunked = c2FmtVersion >= 5;

    // Now either read the raw buffer or decompress the compressed one
    if (m_bCompress)
    {
        // We need to decompress it
        TZLibCompressor zlibDecomp;

        // Get out the compressed byte size
        tCIDLib::TCard4 c4TmpSz;
        strmToReadFrom >> c4TmpSz;

        //
        //  Make sure the buffer is at least the expected decompressed
        //  bytes so that it won't keep expanding and copying the
        //  buffer. Tell it not to maintain current contents.
        //
        if (m_mbufData.c4Size() < m_c4Size)
            m_mbufData.Reallocate(m_c4Size, kCIDLib::False);

        //
        //  Create an output stream over the member buffer, and decompress
        //  from the source stream into the buffer. Since there is more
        //  input in the stream, tell it the max input bytes it can
        //  expect.
        //
        TBinMBufOutStream strmOut(&m_mbufData);
        const tCIDLib::TCard4 c4DSz = zlibDecomp.c4Decompress
        (
            strmToReadFrom, strmOut, c4TmpSz
        );

        //
        //  As a sanity check, make sure that the bytes we got out of
        //  the decompressed size matches what we stored.
        //
        if (c4DSz != m_c4Size)
        {
            facCQCKit().ThrowErr
            (
                CID_FILE
                , CID_LINE
                , kKitErrs::errcPack_BadDecompSz
                , tCIDLib::ESeverities::Failed
                , tCIDLib::EErrClasses::Format
                , TCardinal(c4DSz)
                , TCardinal(m_c4Size)
            );
        }
    }
     else
    {
        // Read it directly into member buffer
        strmToReadFrom.c4ReadBuffer(m_mbufData, m_c4Size);
    }

    // Make sure the checksum checks out
    if (c4CheckSum != m_mbufData.c4CheckSum(0, m_c4Size))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_BadFileCheckSum
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
            , m_strName
        );
    }

    // Ok, and it should end with an end marker
    strmToReadFrom.CheckForEndMarker(CID_FILE, CID_LINE);
}


tCIDLib::TVoid TCQCPackageFl::StreamTo(TBinOutStream& strmToWriteTo) const
{
    //
    //  Checksum the valid buffer bytes. We sum the raw buffer, not the
    //  compressed versin (if compression is being used.)
    //
    const tCIDLib::TCard4 c4CheckSum = m_mbufData.c4CheckSum(0, m_c4Size);

    // Write out the simple stuff first
    strmToWriteTo   << tCIDLib::EStreamMarkers::StartObject
                    << CQCKit_DriverPack::c2FileFmtVersion
                    << c4CheckSum
                    << m_eFileType
                    << m_eFmtType
                    << m_strName
                    << m_bCompress
                    << m_c4Size
                    << m_strUserData
                    << m_bEncrypt;

    //
    //  If this one is going to be compressed, then do that, else we just
    //  write the raw buffer. The raw buffer size is written out above in
    //  either case. If compressed, we also write out the compressed buffer
    //  size.
    //
    if (m_bCompress)
    {
        // We need to decompress it
        TZLibCompressor zlibDecomp;

        //
        //  We have to store the compressed size, so we cannot stream directly
        //  to the output stream. We have to stream to a temp buffer first.
        //  Make it half the source buffer size initially since it'll
        //  probably be text in most cases and will compress very well.
        //  Let it grow up to the twice original size, which will never
        //  happen in reality, but it won't expand unless needed anyway.
        //
        TBinMBufInStream strmSrc(&m_mbufData, m_c4Size);
        THeapBuf mbufTmp(m_c4Size / 2, m_c4Size * 2, m_c4Size / 2);
        TBinMBufOutStream strmTmp(&mbufTmp);
        const tCIDLib::TCard4 c4TmpSz = zlibDecomp.c4Compress(strmSrc, strmTmp);

        //
        //  And now we can write out the size and buffer bytes. We store the
        //  original size, the compressed size, and then the data.
        //
        strmToWriteTo << c4TmpSz;
        strmToWriteTo.c4WriteBuffer(mbufTmp, c4TmpSz);
    }
     else
    {
        // We are writing out the raw buffer
        strmToWriteTo.c4WriteBuffer(m_mbufData, m_c4Size);
    }

    // And cap it off with an end object marker
    strmToWriteTo << tCIDLib::EStreamMarkers::EndObject;
}




// ---------------------------------------------------------------------------
//   CLASS: TCQCPackage
//  PREFIX: pack
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
//  TCQCPackage: Public, static methods
// ---------------------------------------------------------------------------

tCIDLib::TVoid
TCQCPackage::LoadPackage(const TString& strPath, TCQCPackage& packToFill)
{
    // Try to open the file. If it's not there, this will throw
    TBinaryFile flPack(strPath);
    flPack.Open
    (
        tCIDLib::EAccessModes::Excl_Read
        , tCIDLib::ECreateActs::OpenIfExists
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
    );

    // Get the size out, since we'll need it a number of times
    const tCIDLib::TCard4 c4Size = tCIDLib::TCard4(flPack.c8CurSize());

    //
    //  The absolute minimal size it could be is the size of the magic value,
    //  checksum, and version, plusa byte of data. As a practical matter, it
    //  has to be considerably bigger than that, but this is enough to keep
    //  our calculations below from doing bad things.
    //
    if (c4Size < (sizeof(tCIDLib::TCard4) * 2) + sizeof(tCIDLib::TCard2) + 1)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_NotAPackage
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
        );
    }
    const tCIDLib::TCard4 c4DataSize
    (
        c4Size - ((sizeof(tCIDLib::TCard4) * 2) + sizeof(tCIDLib::TCard2))
    );

    // First thing we should see if the magic value
    tCIDLib::TCard4 c4Read;
    tCIDLib::TCard4 c4MagicVal;

    c4Read = flPack.c4ReadBuffer(&c4MagicVal, sizeof(c4MagicVal));
    if (c4Read != sizeof(c4MagicVal))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantReadMagic
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllRead
        );
    }

    if (c4MagicVal != CQCKit_DriverPack::c4MagicVal)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_NotAPackage
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
        );
    }

    //
    //  Next we should see the overall package format version. If it's
    //  pre-version 2, we cannot import it. We changed the versioning scheme
    //  in 1.4.3 and bumped the overall package version to 2. We now reject
    //  any previous versions.
    //
    tCIDLib::TCard2 c2PackVer;
    c4Read = flPack.c4ReadBuffer(&c2PackVer, sizeof(c2PackVer));
    if (c4Read != sizeof(c2PackVer))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantReadVersion
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllRead
        );
    }

    if (c2PackVer < 2)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_UnsupportedPackVer
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllRead
        );
    }

    //
    //  Ok, it's probably fine. So we need to read the bytes between the
    //  version we just read, and the checksum at the end.
    //
    THeapBuf mbufSrc(c4Size, c4Size);
    c4Read = flPack.c4ReadBuffer(mbufSrc, c4DataSize);
    if (c4Read != c4DataSize)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantReadPackage
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllRead
        );
    }

    // Now read in the checksum at the end
    tCIDLib::TCard4 c4Sum;
    c4Read = flPack.c4ReadBuffer(&c4Sum, sizeof(tCIDLib::TCard4));
    if (c4Read != sizeof(tCIDLib::TCard4))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantReadSum
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllRead
        );
    }

    // And we can close the file now
    flPack.Close();

    // Check the sum against what we read
    if (mbufSrc.c4CheckSum(0, c4DataSize) != c4Sum)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_BadFileCheckSum
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
            , strPath
        );
    }

    // Create an input stream over the buffer, and stream in the package
    TBinMBufInStream strmSrc(&mbufSrc, c4DataSize);
    strmSrc >> packToFill;
}


//
//  This file does the actual creation of the package file. It puts some
//  sanity check stuff around the package data.
//
tCIDLib::TVoid
TCQCPackage::MakePackage(const TString& strPath, const TCQCPackage& packSrc)
{
    //
    //  First we stream it to a memory stream, so that we can checksum the
    //  whole package. It could be pretty large if it's an image pack, so we
    //  have to up the default max buffer size to keep it from choking if
    //  so. We'll let it grow up to 32MB.
    //
    TBinMBufOutStream strmPackage(32 * 1024, 32 * (1024 * 1024));
    strmPackage << packSrc << kCIDLib::FlushIt;

    // Checksum the buffer now
    const tCIDLib::TCard4 c4DataSz = strmPackage.c4CurSize();
    const tCIDLib::TCard4 c4Sum = strmPackage.mbufData().c4CheckSum(0, c4DataSz);

    // Open a file for the original selected target name
    TBinaryFile flPack(strPath);
    flPack.Open
    (
        tCIDLib::EAccessModes::Excl_Write
        , tCIDLib::ECreateActs::CreateAlways
        , tCIDLib::EFilePerms::Default
        , tCIDLib::EFileFlags::SequentialScan
    );

    // Write a magic value first
    tCIDLib::TCard4 c4Written = flPack.c4WriteBuffer
    (
        &CQCKit_DriverPack::c4MagicVal, sizeof(tCIDLib::TCard4)
    );

    if (c4Written != sizeof(tCIDLib::TCard4))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantWriteMagic
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllWritten
        );
    }

    // Write the overall package format version
    c4Written = flPack.c4WriteBuffer
    (
        &CQCKit_DriverPack::c2FmtVersion, sizeof(tCIDLib::TCard2)
    );

    if (c4Written != sizeof(tCIDLib::TCard2))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantWriteVersion
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllWritten
        );
    }

    // Now write the package data
    c4Written = flPack.c4WriteBuffer(strmPackage.mbufData(), c4DataSz);
    if (c4Written != c4DataSz)
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantWritePackage
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllWritten
        );
    }

    // And finally write the checksum
    c4Written = flPack.c4WriteBuffer(&c4Sum, sizeof(c4Sum));
    if (c4Written != sizeof(c4Sum))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_CantWriteSum
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::NotAllWritten
        );
    }
}



// ---------------------------------------------------------------------------
//  TCQCPackage: Constructors and Destructor
// ---------------------------------------------------------------------------
TCQCPackage::TCQCPackage() :

    m_c8CreateVer(0)
    , m_eType(tCQCKit::EPackTypes::Count)
{
}

TCQCPackage::TCQCPackage(const  tCQCKit::EPackTypes eType
                        , const tCIDLib::TCard8     c8CreateVer) :

    m_c8CreateVer(c8CreateVer)
    , m_eType(eType)
{
}

TCQCPackage::TCQCPackage(const TCQCPackage& packSrc) :

    m_c8CreateVer(packSrc.m_c8CreateVer)
    , m_colFiles(packSrc.m_colFiles)
    , m_eType(packSrc.m_eType)
    , m_strUserData(packSrc.m_strUserData)
{
}

TCQCPackage::TCQCPackage(TCQCPackage&& packSrc) :

    TCQCPackage()
{
    *this = tCIDLib::ForceMove(packSrc);
}

TCQCPackage::~TCQCPackage()
{
}


// ---------------------------------------------------------------------------
//  TCQCPackage: Public operators
// ---------------------------------------------------------------------------
TCQCPackage& TCQCPackage::operator=(const TCQCPackage& packSrc)
{
    if (this != &packSrc)
    {
        m_c8CreateVer   = packSrc.m_c8CreateVer;
        m_colFiles      = packSrc.m_colFiles;
        m_eType         = packSrc.m_eType;
        m_strUserData   = packSrc.m_strUserData;
    }
    return *this;
}

TCQCPackage& TCQCPackage::operator=(TCQCPackage&& packSrc)
{
    if (this != &packSrc)
    {
        tCIDLib::Swap(m_c8CreateVer, packSrc.m_c8CreateVer);
        tCIDLib::Swap(m_eType, packSrc.m_eType);

        m_colFiles      = tCIDLib::ForceMove(packSrc.m_colFiles);
        m_strUserData   = tCIDLib::ForceMove(packSrc.m_strUserData);
    }
    return *this;
}


// ---------------------------------------------------------------------------
//  TCQCPackage: Public, non-virtual methods
// ---------------------------------------------------------------------------

//
//  This is provided to help the package management dialog know that some
//  files cannot be deleted from the package by the user (since it wouldn't
//  be a valid package anymore.)
//
tCIDLib::TBoolean TCQCPackage::bCanDelete(const tCIDLib::TCard4 c4AtIndex) const
{
    //
    //  If it's a driver type, then they cannot delete the first two files,
    //  which are the manifest file and either the session CML class or the
    //  PDL file.
    //
    if (((m_eType == tCQCKit::EPackTypes::ProtocolDrv)
    ||  (m_eType == tCQCKit::EPackTypes::CMLDrv))
    &&  (c4AtIndex < 2))
    {
        return kCIDLib::False;
    }
    return kCIDLib::True;
}


tCIDLib::TBoolean
TCQCPackage::bFileIsInPackage(  const   TString&                strToFind
                                , const tCQCKit::EPackFlTypes   eType
                                ,       tCIDLib::TCard4&        c4Index) const
{
    // Make sure it's not already in the list
    const tCIDLib::TCard4 c4Count = m_colFiles.c4ElemCount();
    for (c4Index = 0; c4Index < c4Count; c4Index++)
    {
        //
        //  If it has the same name, and is of the same type, then it is
        //  already in the list.
        //
        const TCQCPackageFl& pflCur = m_colFiles[c4Index];
        if ((pflCur.strName() == strToFind) && (pflCur.eFileType() == eType))
            return kCIDLib::True;
    }
    return kCIDLib::False;
}


tCIDLib::TBoolean TCQCPackage::bIsDriverType() const
{
    return ((m_eType == tCQCKit::EPackTypes::ProtocolDrv)
           || (m_eType == tCQCKit::EPackTypes::CMLDrv));
}


tCIDLib::TBoolean TCQCPackage::bRemoveFile(const TString& strFileName)
{
    const tCIDLib::TCard4 c4Count = m_colFiles.c4ElemCount();
    for (tCIDLib::TCard4 c4Index = 0; c4Index < c4Count; c4Index++)
    {
        if (m_colFiles[c4Index].strName() == strFileName)
        {
            m_colFiles.RemoveAt(c4Index);
            return kCIDLib::True;
        }
    }

    // Never found it
    return kCIDLib::False;
}


//
//  These add a new file (text or binary) to the package. We return the index of the
//  new file. This is for data server based resources, which we read down as chunked
//  files and store as such. For special case stuff, like the device map, use the
//  other version.
//
tCIDLib::TCard4
TCQCPackage::c4AddFile( const   tCQCKit::EPackFlTypes   eFlType
                        , const TString&                strFileName
                        , const TChunkedFile&           chflToAdd
                        , const tCIDLib::TBoolean       bCompress
                        , const tCIDLib::TBoolean       bEncrypt)
{
    // Make sure it's not already in the list
    tCIDLib::TCard4 c4Index;
    if (bFileIsInPackage(strFileName, eFlType, c4Index))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_FileAlreadyAdded
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Already
            , strFileName
        );
    }

    //
    //  If this is a driver type package, and this is the first file being
    //  added, make sure it's a manifest. If it's not a driver package, it
    //  shouldn't have a manifest.
    //
    if (m_colFiles.bIsEmpty()
    &&  ((m_eType == tCQCKit::EPackTypes::ProtocolDrv)
    ||   (m_eType == tCQCKit::EPackTypes::CMLDrv))
    &&  (eFlType != tCQCKit::EPackFlTypes::Manifest))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_ManifestNotFirst
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::AppError
        );
    }

    const tCIDLib::TCard4 c4Ret = m_colFiles.c4ElemCount();
    m_colFiles.objPlace(eFlType, strFileName, chflToAdd, bCompress, bEncrypt);
    return c4Ret;
}

tCIDLib::TCard4
TCQCPackage::c4AddFile( const   tCQCKit::EPackFlTypes   eFlType
                        , const TString&                strFileName
                        , const TString&                strText
                        , const tCIDLib::TBoolean       bEncrypt)
{
    // Make sure it's not already in the list
    tCIDLib::TCard4 c4Index;
    if (bFileIsInPackage(strFileName, eFlType, c4Index))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_FileAlreadyAdded
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Already
            , strFileName
        );
    }
    const tCIDLib::TCard4 c4Ret = m_colFiles.c4ElemCount();
    m_colFiles.objPlace(eFlType, strFileName, strText, kCIDLib::True, bEncrypt);
    return c4Ret;
}

tCIDLib::TCard4
TCQCPackage::c4AddFile( const   tCQCKit::EPackFlTypes   eFlType
                        , const TString&                strFileName
                        , const TMemBuf&                mbufData
                        , const tCIDLib::TCard4         c4Bytes
                        , const tCIDLib::TBoolean       bCompress
                        , const tCIDLib::TBoolean       bEncrypt)
{
    // Make sure it's not already in the list
    tCIDLib::TCard4 c4Index;
    if (bFileIsInPackage(strFileName, eFlType, c4Index))
    {
        facCQCKit().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kKitErrs::errcPack_FileAlreadyAdded
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Already
            , strFileName
        );
    }
    const tCIDLib::TCard4 c4Ret = m_colFiles.c4ElemCount();
    m_colFiles.objPlace(eFlType, strFileName, mbufData, c4Bytes, bCompress, bEncrypt);
    return c4Ret;
}


// Returns the count of files current in the package
tCIDLib::TCard4 TCQCPackage::c4FileCount() const
{
    return m_colFiles.c4ElemCount();
}


// Retursn the version of CQC that created this package
tCIDLib::TCard8 TCQCPackage::c8CreateVer() const
{
    return m_c8CreateVer;
}


// Return a ref to the file object as the indicated index
const TCQCPackageFl& TCQCPackage::pflAt(const tCIDLib::TCard4 c4At) const
{
    return m_colFiles[c4At];
}


// Retursn the package type
tCQCKit::EPackTypes TCQCPackage::eType() const
{
    return m_eType;
}


// Set up or reset a package after the fact
tCIDLib::TVoid
TCQCPackage::Initialize(const   tCQCKit::EPackTypes eType
                        , const tCIDLib::TCard8     c8CreateVer)
{
    m_eType = eType;
    m_c8CreateVer = c8CreateVer;
    m_colFiles.RemoveAll();
    m_strUserData.Clear();
}


tCIDLib::TVoid TCQCPackage::RemoveFileAt(const tCIDLib::TCard4 c4At)
{
    CIDAssert(bCanDelete(c4At), L"The file cannot be removed from the package");
    m_colFiles.RemoveAt(c4At);
}




// Set/get the user data field
const TString& TCQCPackage::strUserData() const
{
    return m_strUserData;
}

const TString& TCQCPackage::strUserData(const TString& strToSet)
{
    m_strUserData = strToSet;
    return m_strUserData;
}


// ---------------------------------------------------------------------------
//  TCQCPackage: Protected, inherited methods
// ---------------------------------------------------------------------------
tCIDLib::TVoid TCQCPackage::StreamFrom(TBinInStream& strmToReadFrom)
{
    // Make sure we get the start marker
    strmToReadFrom.CheckForStartMarker(CID_FILE, CID_LINE);

    // Stream in the format version and make sure its good
    tCIDLib::TCard2 c2FmtVersion;
    strmToReadFrom  >> c2FmtVersion;
    if (!c2FmtVersion || (c2FmtVersion > CQCKit_DriverPack::c2PackFmtVersion))
    {
        // We are throwing a CIDLib error here, not ours
        facCIDLib().ThrowErr
        (
            CID_FILE
            , CID_LINE
            , kCIDErrs::errcGen_UnknownFmtVersion
            , tCIDLib::ESeverities::Failed
            , tCIDLib::EErrClasses::Format
            , TCardinal(c2FmtVersion)
            , clsThis()
        );
    }

    strmToReadFrom  >> m_c8CreateVer
                    >> m_eType
                    >> m_colFiles;

    // If V2 or greater, read in the user data, else default it
    if (c2FmtVersion >= 2)
        strmToReadFrom >> m_strUserData;
    else
        m_strUserData.Clear();

    // Ok, and it should end with an end marker
    strmToReadFrom.CheckForEndMarker(CID_FILE, CID_LINE);
}


tCIDLib::TVoid TCQCPackage::StreamTo(TBinOutStream& strmToWriteTo) const
{
    strmToWriteTo   << tCIDLib::EStreamMarkers::StartObject
                    << CQCKit_DriverPack::c2PackFmtVersion
                    << m_c8CreateVer
                    << m_eType
                    << m_colFiles
                    << m_strUserData
                    << tCIDLib::EStreamMarkers::EndObject;
}


